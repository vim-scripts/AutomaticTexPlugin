" Vim library for atp filetype plugin
" Language:	tex
" Maintainer:	Marcin Szamotulski
" Last Changed: 2010 June 13
" Email:	mszamot [AT] gmail [DOT] com

"{{{1 atplib#outdir
function! atplib#outdir()
    if b:outdir !~ "\/$"
	let b:outdir=b:outdir . "/"
    endif
endfunction
"}}}1
" {{{1 atplib#LABELS
" the argument should be: resolved full path to the file:
" resove(fnamemodify(bufname("%"),":p"))

" {{{2 --------------- atplib#generatelabels
function! atplib#generatelabels(filename)
    let s:labels={}
    let l:bufname=fnamemodify(a:filename,":t")
    " getbufline reads onlu loaded buffers, unloaded can be read from file.
    if bufloaded("^" . l:bufname . "$")
	let l:texfile=getbufline("^" . l:bufname . "$","1","$")
    else
	w
	let l:texfile=readfile(a:filename)
    endif
"     echomsg "DEBUG X        " . fnamemodify(a:filename,":t")
    let l:true=1
    let l:i=0
    " remove the bart before \begin{document}
    while l:true == 1
	if l:texfile[0] =~ '\\begin\s*{document}'
		let l:true=0
	endif
	call remove(l:texfile,0)
	let l:i+=1
    endwhile
    let l:bline=l:i
    let l:i=0
    while l:i < len(l:texfile)
	if l:texfile[l:i] =~ '\\label\s*{'
	    let l:lname=matchstr(l:texfile[l:i],'\\label\s*{.*','')
	    let l:start=stridx(l:lname,'{')+1
	    let l:lname=strpart(l:lname,l:start)
	    let l:end=stridx(l:lname,'}')
	    let l:lname=strpart(l:lname,0,l:end)
	    let b:lname=l:lname
    "This can be extended to have also the whole environmet which
    "could be shown.
	    call extend(s:labels,{ l:i+l:bline+1 : l:lname })
	endif
	let l:i+=1 
    endwhile
    if exists("t:labels")
	call extend(t:labels,{ a:filename : s:labels },"force")
    else
	let t:labels={ a:filename : s:labels }
    endif
    return t:labels
endfunction
" }}}2
" {{{2 --------------- atplib#showlabels
" The argument is the dictionary generated by atplib#generatelabels.
function! atplib#showlabels(labels)
    " the argument a:labels=t:labels[bufname("")] !
    let l:cline=line(".")
    let l:lines=sort(keys(a:labels),"atplib#CompareList")
    " Open new window or jump to the existing one.
    let l:bufname=bufname("")
"     let l:bufpath=fnamemodify(bufname(""),":p:h")
    let l:bufpath=fnamemodify(resolve(fnamemodify(bufname("%"),":p")),":h")
    let l:bname="__Labels__"
    let l:labelswinnr=bufwinnr("^" . l:bname . "$")
    let t:labelswinnr=winnr()
    let t:labelsbufnr=bufnr("^" . l:bname . "$") 
    let l:labelswinnr=bufwinnr(t:labelsbufnr)
    if l:labelswinnr != -1
	" Jump to the existing window.
	exe l:labelswinnr . " wincmd w"
	if l:labelswinnr != t:labelswinnr
	    silent exe "%delete"
	else
	    echoerr "ATP error in function s:showtoc, TOC/LABEL buffer 
		    \ and the tex file buffer agree."
	    return
	endif
    else
    " Open new window if its width is defined (if it is not the code below
    " will put lab:cels in the current buffer so it is better to return.
	if !exists("t:labels_window_width")
	    echoerr "t:labels_window_width not set"
	    return
	endif
	let l:openbuffer=t:labels_window_width . "vsplit +setl\\ buftype=nofile\\ filetype=toc_atp\\ syntax=labels_atp __Labels__"
	silent exe l:openbuffer
	silent call atplib#s:setwindow()
	let t:labelsbufnr=bufnr("")
    endif
    call setline(1,l:bufname . " (" . l:bufpath . ")")
    let l:ln=2
    for l:line in l:lines
	call setline(l:ln, l:line . "\t" . a:labels[l:line]) 
	let l:ln+=1
    endfor
    " set the cursor position on the correct line number.
    let l:number=1
    for l:line in l:lines
    if l:cline>=l:line
	keepjumps call setpos('.',[bufnr(bufname('%')),l:number+1,1,0])
    elseif l:number == 1 && l:cline<l:line
	keepjumps call setpos('.',[bufnr(bufname('%')),l:number+1,1,0])
    endif
    let l:number+=1
    endfor
endfunction
" }}}2
" }}}1
"{{{1 atplib#CompareList
function! atplib#CompareList(i1, i2)
   return str2nr(a:i1) == str2nr(a:i2) ? 0 : str2nr(a:i1) > str2nr(a:i2) ? 1 : -1
endfunction
"}}}1
" {{{1 atplib#CompareCoordinates
" Each list is ann argument with two values!
" listA=[line_nrA,col_nrA] usually given by searchpos() function
" listB=[line_nrB,col_nrB]
" returns 1 iff A is smaller than B
fun! atplib#CompareCoordinates(listA,listB)
    if a:listA[0] < a:listB[0] || 
	\ a:listA[0] == a:listB[0] && a:listA[1] < a:listB[1] ||
	\ a:listA == [0,0]
	" the meaning of the last is that if the searchpos() has not found the
	" begining (a:listA) then it should return 1 : the env is not started.
	return 1
    else
	return 0
    endif
endfun
"}}}1
" {{{1 atplib#ReadInputFile
" this function looks for an input file: in the list of buffers, under a path if
" it is given, then in the b:outdir.
" directory. The last argument if equal to 1, then look also
" under g:texmf.
function! atplib#ReadInputFile(ifile,check_texmf)

    let l:input_file = []

    " read the buffer or read file if the buffer is not listed.
    if buflisted(fnamemodify(a:ifile,":t"))
	let l:input_file=getbufline(fnamemodify(a:ifile,":t"),1,'$')
    " if the ifile is given with a path it should be tried to reaad from there
    elseif filereadable(a:ifile)
	let l:input_file=readfile(a:ifile)
    " if not then try to read it from b:outdir
    elseif filereadable(b:outdir . fnamemodify(a:ifile,":t"))
	let l:input_file=readfile(filereadable(b:outdir . fnamemodify(a:ifile,":t")))
    " the last chance is to look for it in the g:texmf directory
    elseif a:check_texmf && filereadable(findfile(a:ifile,g:texmf . '**'))
	let l:input_file=readfile(findfile(a:ifile,g:texmf . '**'))
    endif

    return l:input_file
endfunction
" }}}1
"{{{1 BIBSEARCH
"{{{2 atplib#variables
let atplib#bibflagsdict={ 't' : ['title', 'title        '] , 'a' : ['author', 'author       '], 
		\ 'b' : ['booktitle', 'booktitle    '], 'c' : ['mrclass', 'mrclass      '], 
		\ 'e' : ['editor', 'editor       '], 	'j' : ['journal', 'journal      '], 
		\ 'f' : ['fjournal', 'fjournal     '], 	'y' : ['year', 'year         '], 
		\ 'n' : ['number', 'number       '], 	'v' : ['volume', 'volume       '], 
		\ 's' : ['series', 'series       '], 	'p' : ['pages', 'pages        '], 
		\ 'P' : ['publisher', 'publisher    '], 'N' : ['note', 'note         '], 
		\ 'S' : ['school', 'school       '], 	'h' : ['howpublished', 'howpublished '], 
		\ 'o' : ['organization', 'organization '], 'I' : ['institution' , 'institution '],
		\ 'u' : ['url', 'url          '],
		\ 'H' : ['homepage', 'homepage     '], 	'i' : ['issn', 'issn         '],
		\ 'k' : ['key', 'key          ']}
" they do not work in the library script :(
" using g:bibflags... .
" let atplib#bibflagslist=keys(atplib#bibflagsdict)
" let atplib#bibflagsstring=join(atplib#bibflagslist,'')
"}}}2
"{{{2 atplib#searchbib
" ToDo should not search in comment lines.

" To make it work afet kpsewhich is searching for bib path.
" let s:bibfiles=FindBibFiles(bufname('%'))
function! atplib#searchbib(pattern) 
" 	echomsg "DEBUG pattern" a:pattern
    call atplib#outdir()
    let s:bibfiles=keys(FindBibFiles(bufname('%')))
    
    " Make a pattern which will match for the elements of the list g:bibentries
    let l:pattern = '^\s*@\%(\<'.g:bibentries[0].'\>'
    for l:bibentry in g:bibentries['1':len(g:bibentries)]
	let l:pattern=l:pattern . '\|\<' . l:bibentry . '\>'
    endfor
    let l:pattern=l:pattern . '\)'
    let b:pattern=l:pattern
" This pattern matches all entry lines: author = \| title = \| ... 
    let l:pattern_b = '^\s*\%('
    for l:bibentry in keys(g:bibflagsdict)
	let l:pattern_b=l:pattern_b . '\|\<' . g:bibflagsdict[l:bibentry][0] . '\>'
    endfor
    let l:pattern_b.='\)\s*='
    let b:pattern_b=l:pattern_b

    unlet l:bibentry
    let b:bibentryline={} 
    
    " READ EACH BIBFILE IN TO DICTIONARY s:bibdict, WITH KEY NAME BEING THE bibfilename
    let s:bibdict={}
    let l:bibdict={}
    for l:f in s:bibfiles
	let s:bibdict[l:f]=[]

	" read the bibfile if it is in b:outdir or in g:atp_bibinputs directory
	" ToDo: change this to look in directories under g:atp_bibinputs. 
	" (see also ToDo in FindBibFiles 284)
	for l:path in g:atp_bibinputs 
	    " it might be problem when there are multiple libraries with the
	    " same name under different locations (only the last one will
	    " survive)
	    let s:bibdict[l:f]=readfile(fnameescape(findfile(atplib#append(l:f,'.bib'),atplib#append(l:path,"/") . "**")))
	endfor
	let l:bibdict[l:f]=copy(s:bibdict[l:f])
	" clear the s:bibdict values from lines which begin with %    
	" SPEED UP
	call filter(l:bibdict[l:f],' v:val !~ "^\\s*\\%(%\\|@\\cstring\\)"')
" 	let l:x=0
" 	for l:line in s:bibdict[l:f]
" 	    if l:line =~ '^\s*\%(%\|@\cstring\)' 
" 		call remove(l:bibdict[l:f],l:x)
" 	    else
" 		let l:x+=1
" 	    endif
" 	endfor
" 	unlet l:line
" 	END SPEED UP
    endfor
    let b:bibdict=deepcopy(l:bibdict)	" DEBUG

    " SPEED UP TODO: if a:pattern == "" there is no need to do that!
    " uncomment this when the rest will be ready!
    if a:pattern != ""
	for l:f in s:bibfiles
	    let l:list=[]
	    let l:nr=1
	    for l:line in l:bibdict[l:f]
		" if the line matches find the begining of this bib field and add its
		" line number to the list l:list
		if substitute(l:line,'{\|}','','g') =~ a:pattern
		    let l:true=1
		    let l:t=0
		    while l:true == 1
			let l:tnr=l:nr-l:t
			" go back until the line will match l:pattern (which
			" shoulf be the beginning of the bib field.
		       if l:bibdict[l:f][l:tnr-1] =~ l:pattern && l:tnr >= 0
			   let l:true=0
			   let l:list=add(l:list,l:tnr)
		       elseif l:tnr <= 0
			   let l:true=0
		       endif
		       let l:t+=1
		    endwhile
		endif
		let l:nr+=1
	    endfor
    " CLEAR THE l:list FROM ENTRIES WHICH APPEAR TWICE OR MORE --> l:clist
	    let l:pentry="A"		" We want to ensure that l:entry (a number) and l:pentry are different
	    for l:entry in l:list
		if l:entry != l:pentry
		    if count(l:list,l:entry) > 1
			while count(l:list,l:entry) > 1
			    let l:eind=index(l:list,l:entry)
			    call remove(l:list,l:eind)
			endwhile
		    endif 
		    let l:pentry=l:entry
		endif
	    endfor
	    let b:bibentryline=extend(b:bibentryline,{ l:f : l:list })
	endfor
    endif
"   CHECK EACH BIBFILE
    let l:bibresults={}

" NEW CODE: (shows only every second match ?!)
"     if the pattern was empty make it faster. 
    if a:pattern == ""
	for l:bibfile in keys(l:bibdict)
	    let l:bibfile_len=len(l:bibdict[l:bibfile])
	    let s:bibd={}
		let l:nr=0
		while l:nr < l:bibfile_len
		    let l:line=l:bibdict[l:bibfile][l:nr]
" 		    echomsg "LINE " . l:nr . "  " .  (l:line =~ l:pattern) . " line " . l:line
		    if l:line =~ l:pattern
			let s:lbibd={}
			let s:lbibd["bibfield_key"]=l:line
			let l:beg_line=l:nr+1
			let l:nr+=1
			let l:line=l:bibdict[l:bibfile][l:nr]
			let l:y=1
			while l:line !~ l:pattern && l:nr < l:bibfile_len
			    let l:line=l:bibdict[l:bibfile][l:nr]
			    let l:lkey=tolower(
					\ matchstr(
					    \ strpart(l:line,0,
						\ stridx(l:line,"=")
					    \ ),'\<\w*\>'
					\ ))
			" CONCATENATE LINES IF IT IS NOT ENDED
			    let l:y=1
			    if l:lkey != ""
				let s:lbibd[l:lkey]=l:line
	" IF THE LINE IS SPLIT ATTACH NEXT LINE									
" 				echomsg "l:nr=".l:nr. "       line=".l:line 
				let l:nline=get(l:bibdict[l:bibfile],l:nr+l:y)
" 				while l:line !~ '\%()\|}\|"\)\?\s*,\s*\%(%.*\)\?$' && 
" 					    \ l:nline !~ l:pattern
				while l:nline !~ '=' && 
					    \ l:nline !~ l:pattern &&
					    \ (l:nr+l:y) < l:bibfile_len
" 				THIS IS FAST BUT CAN BREAK FROM TIME TO TIME
" 				(for example if the title contains = )
" 				instead of l:nline !~ '=' it is better to
" 				check: 
" 				while l:nline !~ l:pattern_b &&
" 					    \ l:nline !~ l:pattern &&
" 					    \ (l:nr+l:y) < l:bibfile_len
" 			        (BUT IT TAKES 1s more!)  
				    let s:lbibd[l:lkey]=substitute(s:lbibd[l:lkey],'\s*$','','') . " ". substitute(get(l:bibdict[l:bibfile],l:nr+l:y),'^\s*','','')
				    let l:line=get(l:bibdict[l:bibfile],l:nr+l:y)
" 				    echomsg "l:nr=".l:nr. " l:y=".l:y." line=".l:line 
				    let l:y+=1
				    let l:nline=get(l:bibdict[l:bibfile],l:nr+l:y)
				    if l:y > 30
					echoerr "ATP-Error /see :h atp-errors-bibsearch/, missing '}', ')' or '\"' in bibentry (check line " . l:nr . ") in " . l:f . " line=".l:line
					break
				    endif
				endwhile
				if l:nline =~ l:pattern 
" 				    echomsg "BREAK l:nr=".l:nr. " l:y=".l:y." nline=".l:nline 
				    let l:y=1
				endif
" 				OLD MECHANISM OF ATTACHING LINES
" 				echomsg "l:nr=".l:nr. "       line=".l:line 
" 				if l:line !~ '\%()\|}\|"\)\s*,\s*\%(%.*\)\?$'
" 				    let l:lline=substitute(l:line,'\\"\|\\{\|\\}\|\\(\|\\)','','g')
" 				    let l:pos=atplib#count(l:lline,"{")
" 				    let l:neg=atplib#count(l:lline,"}")
" 				    let l:m=l:pos-l:neg
" 				    let l:pos=atplib#count(l:lline,"(")
" 				    let l:neg=atplib#count(l:lline,")")
" 				    let l:n=l:pos-l:neg
" 				    let l:o=atplib#count(l:lline,"\"")
" 	    " this checks if bracets {}, and () and "" appear in pairs in the current line:  
" 				    if l:m>0 || l:n>0 || l:o>l:o/2*2 
" 					while l:m>0 || l:n>0 || l:o>l:o/2*2 
" 					    let l:pos=atplib#count(get(l:bibdict[l:bibfile],l:nr+l:y),"{")
" 					    let l:neg=atplib#count(get(l:bibdict[l:bibfile],l:nr+l:y),"}")
" 					    let l:m+=l:pos-l:neg
" 					    let l:pos=atplib#count(get(l:bibdict[l:bibfile],l:nr+l:y),"(")
" 					    let l:neg=atplib#count(get(l:bibdict[l:bibfile],l:nr+l:y),")")
" 					    let l:n+=l:pos-l:neg
" 					    let l:o+=atplib#count(get(l:bibdict[l:bibfile],l:nr+l:y),"\"")
" 	    " Let's append the next line: 
" 					    let s:lbibd[l:lkey]=substitute(s:lbibd[l:lkey],'\s*$','','') . " ". substitute(get(l:bibdict[l:bibfile],l:nr+l:y),'^\s*','','')
" 					    let l:y+=1
" 					    if l:y > 30
" 						echoerr "ATP-Error /see :h atp-errors-bibsearch/, missing '}', ')' or '\"' in bibentry at line " . l:linenr . " (check line " . l:nr . ") in " . l:f
" 						break
" 					    endif
" 					endwhile
" 				    endif
" 				endif
" 			    END OF OLD MECHANISM OF ATTACHING LINES




			    endif
" 			    echomsg "SUB LINE l:nr" . l:nr . "  l:y" . l:y
			    let l:nr+=l:y
			    unlet l:y
			endwhile
			let l:nr-=1
" 			echomsg "END WHILE " . l:nr
" 			echo s:lbibd
			call extend(s:bibd, { l:beg_line : s:lbibd })
		    else
			let l:nr+=1
		    endif
" 		    echomsg "LINE END " . l:nr . " " .  l:bibdict[l:bibfile][l:nr]
		endwhile
	    let l:bibresults[l:bibfile]=s:bibd
	    let g:bibresults=l:bibresults
	endfor
	let g:bbibresults=l:bibresults
	return l:bibresults
    endif
    " END OF NEW CODE: (up)

    for l:bibfile in keys(b:bibentryline)
	let l:f=l:bibfile . ".bib"
"s:bibdict[l:f])	CHECK EVERY STARTING LINE (we are going to read bibfile from starting
"	line till the last matching } 
 	let s:bibd={}
 	for l:linenr in b:bibentryline[l:bibfile]
"
" 	new algorithm is on the way, using searchpair function
" 	    l:time=0
" 	    l:true=1
" 	    let b:pair1=searchpair('(','',')','b')
" 	    let b:pair2=searchpair('{','','}','b')
" 	    let l:true=b:pair1+b:pair2
" 	    while l:true == 0
" 		let b:pair1p=b:pair1	
" 		let b:pair1=searchpair('(','',')','b')
" 		let b:pair2p=b:pair2	
" 		let b:pair2=searchpair('{','','}','b')
" 		let l:time+=1
" 	    endwhile
" 	    let l:bfieldline=l:time

	    let l:nr=l:linenr-1
	    let l:i=atplib#count(get(l:bibdict[l:bibfile],l:linenr-1),"{")-atplib#count(get(l:bibdict[l:bibfile],l:linenr-1),"}")
	    let l:j=atplib#count(get(l:bibdict[l:bibfile],l:linenr-1),"(")-atplib#count(get(l:bibdict[l:bibfile],l:linenr-1),")") 
	    let s:lbibd={}
	    let s:lbibd["bibfield_key"]=get(l:bibdict[l:bibfile],l:linenr-1)
	    let l:x=1
" we go from the first line of bibentry, i.e. @article{ or @article(, until the { and (
" will close. In each line we count brackets.	    
            while l:i>0	|| l:j>0
		let l:tlnr=l:x+l:linenr
		let l:pos=atplib#count(get(l:bibdict[l:bibfile],l:tlnr-1),"{")
		let l:neg=atplib#count(get(l:bibdict[l:bibfile],l:tlnr-1),"}")
		let l:i+=l:pos-l:neg
		let l:pos=atplib#count(get(l:bibdict[l:bibfile],l:tlnr-1),"(")
		let l:neg=atplib#count(get(l:bibdict[l:bibfile],l:tlnr-1),")")
		let l:j+=l:pos-l:neg
		let l:lkey=tolower(
			    \ matchstr(
				\ strpart(get(l:bibdict[l:bibfile],l:tlnr-1),0,
				    \ stridx(get(l:bibdict[l:bibfile],l:tlnr-1),"=")
				\ ),'\<\w*\>'
			    \ ))
		if l:lkey != ""
		    let s:lbibd[l:lkey]=get(l:bibdict[l:bibfile],l:tlnr-1)
			let l:y=0
" IF THE LINE IS SPLIT ATTACH NEXT LINE									
			if get(l:bibdict[l:bibfile],l:tlnr-1) !~ '\%()\|}\|"\)\s*,\s*\%(%.*\)\?$'
" 				    \ get(l:bibdict[l:bibfile],l:tlnr) !~ l:pattern_b
			    let l:lline=substitute(get(l:bibdict[l:bibfile],l:tlnr+l:y-1),'\\"\|\\{\|\\}\|\\(\|\\)','','g')
			    let l:pos=atplib#count(l:lline,"{")
			    let l:neg=atplib#count(l:lline,"}")
			    let l:m=l:pos-l:neg
			    let l:pos=atplib#count(l:lline,"(")
			    let l:neg=atplib#count(l:lline,")")
			    let l:n=l:pos-l:neg
			    let l:o=atplib#count(l:lline,"\"")
    " this checks if bracets {}, and () and "" appear in pairs in the current line:  
			    if l:m>0 || l:n>0 || l:o>l:o/2*2 
				while l:m>0 || l:n>0 || l:o>l:o/2*2 
				    let l:pos=atplib#count(get(l:bibdict[l:bibfile],l:tlnr+l:y),"{")
				    let l:neg=atplib#count(get(l:bibdict[l:bibfile],l:tlnr+l:y),"}")
				    let l:m+=l:pos-l:neg
				    let l:pos=atplib#count(get(l:bibdict[l:bibfile],l:tlnr+l:y),"(")
				    let l:neg=atplib#count(get(l:bibdict[l:bibfile],l:tlnr+l:y),")")
				    let l:n+=l:pos-l:neg
				    let l:o+=atplib#count(get(l:bibdict[l:bibfile],l:tlnr+l:y),"\"")
    " Let's append the next line: 
				    let s:lbibd[l:lkey]=substitute(s:lbibd[l:lkey],'\s*$','','') . " ". substitute(get(l:bibdict[l:bibfile],l:tlnr+l:y),'^\s*','','')
				    let l:y+=1
				    if l:y > 30
					echoerr "ATP-Error /see :h atp-errors-bibsearch/, missing '}', ')' or '\"' in bibentry at line " . l:linenr . " (check line " . l:tlnr . ") in " . l:f
					break
				    endif
				endwhile
			    endif
			endif
		endif
" we have to go line by line and we could skip l:y+1 lines, but we have to
" keep l:m, l:o values. It do not saves much.		
		let l:x+=1
		if l:x > 30
			echoerr "ATP-Error /see :h atp-errors-bibsearch/, missing '}', ')' or '\"' in bibentry at line " . l:linenr . " in " . l:f
			break
	        endif
		let b:x=l:x
		unlet l:tlnr
	    endwhile
	    
	    let s:bibd[l:linenr]=s:lbibd
	    unlet s:lbibd
	endfor
	let l:bibresults[l:bibfile]=s:bibd
    endfor
    let g:bibresults=l:bibresults
    return l:bibresults
endfunction
"}}}2
" {{{2 atplib#SearchBibItems
" the argument should be b:atp_mainfile but in any case it is made in this way.
" it specifies in which file to search for include files.
function! atplib#SearchBibItems(name)

    " we are going to make a dictionary { citekey : label } (see :h \bibitem) 
    let l:citekey_label_dict={}

    " make a list of include files.
    let l:inputfile_dict=FindInputFiles(a:name,0)
    let l:includefile_list=[]
    for l:key in keys(l:inputfile_dict)
	if l:inputfile_dict[l:key][0] =~ '^\%(include\|input\|includeonly\)$'
	    call add(l:includefile_list,atplib#append(l:key,'.tex'))
	endif
    endfor
    call add(l:includefile_list,b:atp_mainfile) 
"     let b:ifl=l:includefile_list

    " search for bibitems in all include files.
    for l:ifile in l:includefile_list

	let l:input_file = atplib#ReadInputFile(l:ifile,0)

	    " search for bibitems and make a dictionary of labels and citekeys
	    for l:line in l:input_file
		if l:line =~ '\\bibitem'
		    let l:label=matchstr(l:line,'\\bibitem\s*\[\zs[^]]*\ze\]')
		    let l:key=matchstr(l:line,'\\bibitem\s*\%(\[[^]]*\]\)\?\s*{\zs[^}]*\ze}') 
" 		    if l:label =~ 'bibitem'
" 			let l:label=''
" 		    endif
		    if l:key != ""
			call extend(l:citekey_label_dict, { l:key : l:label }, 'error') 
		    endif
		endif
	    endfor
    endfor
	
    return l:citekey_label_dict
endfunction
" }}}2
"{{{2 atplib#showresults
" FLAGS:
" for currently supported flags see ':h atp_bibflags'
" All - all flags	
" L - last flag
" a - author
" e - editor
" t - title
" b - booktitle
" j - journal
" s - series
" y - year
" n - number
" v - volume
" p - pages
" P - publisher
" N - note
" S - school
" h - howpublished
" o - organization
" i - institution

function! atplib#showresults(bibresults,flags,pattern)
 
    "if nothing was found inform the user and return:
    if len(a:bibresults) == count(a:bibresults,{})
	echo "BibSearch: no bib fields matched."
	return 0
    endif


    function! s:showvalue(value)
	return substitute(strpart(a:value,stridx(a:value,"=")+1),'^\s*','','')
    endfunction

    let s:z=1
    let l:ln=1
    let l:listofkeys={}
"--------------SET UP FLAGS--------------------------    
	    let l:allflagon=0
	    let l:flagslist=[]
	    let l:kwflagslist=[]
    " flags o and i are synonims: (but refer to different entry keys): 
	if a:flags =~ '\Ci' && a:flags !~ '\Co'
	    let a:flags=substitute(a:flags,'i','io','') 
	elseif a:flags !~ '\Ci' && a:flags =~ '\Co'
	    let a:flags=substitute(a:flags,'o','oi','')
	endif
	if a:flags !~ 'All'
	    if a:flags =~ 'L'
 		if strpart(a:flags,0,1) != '+'
 		    let l:flags=b:lastbibflags . substitute(strpart(a:flags,0),'\CL','','g')
 		else
 		    let l:flags=b:lastbibflags . substitute(a:flags,'\CL','','g')
 		endif
	    else
		if a:flags == "" 
		    let l:flags=g:defaultbibflags
		elseif strpart(a:flags,0,1) != '+' && a:flags !~ 'All' 
		    let l:flags=a:flags
		elseif strpart(a:flags,0,1) == '+' && a:flags !~ 'All'
		    let l:flags=g:defaultbibflags . strpart(a:flags,1)
		endif
	    endif
	    let b:lastbibflags=substitute(l:flags,'+\|L','','g')
		if l:flags != ""
		    let l:expr='\C[' . g:bibflagsstring . ']' 
		    while len(l:flags) >=1
			let l:oneflag=strpart(l:flags,0,1)
    " if we get a flag from the variable g:bibflagsstring we copy it to the list l:flagslist 
			if l:oneflag =~ l:expr
			    let l:flagslist=add(l:flagslist,l:oneflag)
			    let l:flags=strpart(l:flags,1)
    " if we get '@' we eat ;) two letters to the list l:kwflagslist			
			elseif l:oneflag == '@'
			    let l:oneflag=strpart(l:flags,0,2)
			    if index(keys(g:kwflagsdict),l:oneflag) != -1
				let l:kwflagslist=add(l:kwflagslist,l:oneflag)
			    endif
			    let l:flags=strpart(l:flags,2)
    " remove flags which are not defined
			elseif l:oneflag !~ l:expr && l:oneflag != '@'
			    let l:flags=strpart(l:flags,1)
			endif
		    endwhile
		endif
	else
    " if the flag 'All' was specified. 	    
	    let l:flagslist=split(g:defaultallbibflags, '\zs')
	    let l:af=substitute(a:flags,'All','','g')
	    for l:kwflag in keys(g:kwflagsdict)
		if a:flags =~ '\C' . l:kwflag	
		    call extend(l:kwflagslist,[l:kwflag])
		endif
	    endfor
	endif
" 	let b:flagslist=l:flagslist			" DEBUG
" 	let b:kwflagslist=l:kwflagslist			" DEBUG

	"NEW: if there are only keyword flags append default flags
	if len(l:kwflagslist) > 0 && len(l:flagslist) == 0 
	    let l:flagslist=split(g:defaultbibflags,'\zs')
	endif

"   Open a new window.
    let l:bufnr=bufnr("___" . a:pattern . "___"  )
    if l:bufnr != -1
	let l:bdelete=l:bufnr . "bwipeout"
	exe l:bdelete
    endif
    unlet l:bufnr
    let l:openbuffer=" +setl\\ buftype=nofile\\ filetype=bibsearch_atp " . fnameescape("___" . a:pattern . "___")
    if g:vertical ==1
	let l:openbuffer="vsplit " . l:openbuffer 
	let l:skip=""
    else
	let l:openbuffer="split " . l:openbuffer 
	let l:skip="       "
    endif
    silent exe l:openbuffer

"     set the window options
    silent call atplib#setwindow()
" make a dictionary of clear values, which we will fill with found entries. 	    
" the default value is no<keyname>, which after all is matched and not showed
" SPEED UP:
    let l:values={'bibfield_key' : 'nokey'}	
    for l:flag in g:bibflagslist
	let l:values_clear=extend(l:values,{ g:bibflagsdict[l:flag][0] : 'no' . g:bibflagsdict[l:flag][0] })
    endfor

" SPEED UP: 
    let l:kwflag_pattern="\\C"	
    let l:len_kwflgslist=len(l:kwflagslist)
    let l:kwflagslist_rev=reverse(deepcopy(l:kwflagslist))
    for l:lkwflag in l:kwflagslist
	if index(l:kwflagslist_rev,l:lkwflag) == 0 
	    let l:kwflag_pattern.=g:kwflagsdict[l:lkwflag]
	else
	    let l:kwflag_pattern.=g:kwflagsdict[l:lkwflag].'\|'
	endif
    endfor
"     let b:kwflag_pattern=l:kwflag_pattern

    for l:bibfile in keys(a:bibresults)
	if a:bibresults[l:bibfile] != {}
	    call setline(l:ln, "Found in " . l:bibfile )	
	    let l:ln+=1
	endif
	for l:linenr in copy(sort(keys(a:bibresults[l:bibfile]),"atplib#CompareList"))
	    let l:values=deepcopy(l:values_clear)
	    let b:values=l:values
" fill l:values with a:bibrsults	    
	    let l:values["bibfield_key"]=a:bibresults[l:bibfile][l:linenr]["bibfield_key"]
" 	    for l:key in keys(l:values)
" 		if l:key != 'key' && get(a:bibresults[l:bibfile][l:linenr],l:key,"no" . l:key) != "no" . l:key
" 		    let l:values[l:key]=a:bibresults[l:bibfile][l:linenr][l:key]
" 		endif
" SPEED UP:
		call extend(l:values,a:bibresults[l:bibfile][l:linenr],'force')
" 	    endfor
" ----------------------------- SHOW ENTRIES -------------------------
" first we check the keyword flags, @a,@b,... it passes if at least one flag
" is matched
	    let l:check=0
" 	    for l:lkwflag in l:kwflagslist
" 	        let l:kwflagpattern= '\C' . g:kwflagsdict[l:lkwflag]
" 		if l:values['bibfield_key'] =~ l:kwflagpattern
" 		   let l:check=1
" 		endif
" 	    endfor
	    if l:values['bibfield_key'] =~ l:kwflag_pattern
		let l:check=1
	    endif
	    if l:check == 1 || len(l:kwflagslist) == 0
		let l:linenumber=index(s:bibdict[l:bibfile],l:values["bibfield_key"])+1
 		call setline(l:ln,s:z . ". line " . l:linenumber . "  " . l:values["bibfield_key"])
		let l:ln+=1
 		let l:c0=atplib#count(l:values["bibfield_key"],'{')-atplib#count(l:values["bibfield_key"],'(')

	
" this goes over the entry flags:
		for l:lflag in l:flagslist
" we check if the entry was present in bibfile:
		    if l:values[g:bibflagsdict[l:lflag][0]] != "no" . g:bibflagsdict[l:lflag][0]
" 			if l:values[g:bibflagsdict[l:lflag][0]] =~ a:pattern
			    call setline(l:ln, l:skip . g:bibflagsdict[l:lflag][1] . " = " . s:showvalue(l:values[g:bibflagsdict[l:lflag][0]]))
			    let l:ln+=1
" 			else
" 			    call setline(l:ln, l:skip . g:bibflagsdict[l:lflag][1] . " = " . s:showvalue(l:values[g:bibflagsdict[l:lflag][0]]))
" 			    let l:ln+=1
" 			endif
		    endif
		endfor
		let l:lastline=getline(line('$'))
		let l:c1=atplib#count(l:lastline,'{')-atplib#count(l:lastline,'}')
		let l:c2=atplib#count(l:lastline,'(')-atplib#count(l:lastline,')')
		let l:c3=atplib#count(l:lastline,'\"')
" 		echomsg "last line " . line('$') . "     l:ln=" l:ln . "    l:c0=" . l:c0		"DEBUG
		if l:c0 == 1 && l:c1 == -1
		    call setline(line('$'),substitute(l:lastline,'}\s*$','',''))
		    call setline(l:ln,'}')
		    let l:ln+=1
		elseif l:c0 == 1 && l:c1 == 0	
		    call setline(l:ln,'}')
		    let l:ln+=1
		elseif l:c0 == -1 && l:c2 == -1
		    call setline(line('$'),substitute(l:lastline,')\s*$','',''))
		    call setline(l:ln,')')
		    let l:ln+=1
		elseif l:c0 == -1 && l:c1 == 0	
		    call setline(l:ln,')')
		    let l:ln+=1
		endif
		let l:listofkeys[s:z]=l:values["bibfield_key"]
		let s:z+=1
	    endif
	endfor
    endfor
    call matchadd("Search",a:pattern)
    " return l:listofkeys which will be available in the bib search buffer
    " as b:listofkeys (see the BibSearch function below)
    return l:listofkeys
endfunction
"}}}2
"}}}1
"{{{1 atplib#setwindow
" this function sets the options of BibSearch, ToC and Labels windows.
function! atplib#setwindow()
" These options are set in the command line
" +setl\\ buftype=nofile\\ filetype=bibsearch_atp   
" +setl\\ buftype=nofile\\ filetype=toc_atp\\ nowrap
" +setl\\ buftype=nofile\\ filetype=toc_atp\\ syntax=labels_atp
	setlocal nonumber
 	setlocal winfixwidth
	setlocal noswapfile	
	setlocal window
	setlocal nobuflisted
	if &filetype == "bibsearch_atp"
" 	    setlocal winwidth=30
	    setlocal nospell
	elseif &filetype == "toc_atp"
" 	    setlocal winwidth=20
	    setlocal nospell
	endif
endfunction
" }}}1
" {{{1 atplib#count
function! atplib#count(line,keyword,...)
   
    if a:0 == 0 || a:1 == 0
	let l:method=0
    elseif a:1 == 1
	let l:method=1
    endif

    let l:line=a:line
    let l:i=0  
    if l:method==0
	while stridx(l:line,a:keyword) != '-1'
" 		if stridx(l:line,a:keyword) !='-1' 
	    let l:line=strpart(l:line,stridx(l:line,a:keyword)+1)
" 		endif
	    let l:i+=1
	endwhile
    elseif l:method==1
	let l:line=escape(l:line,'\\')
" 	let b:line=l:line " DEBUG
	while match(l:line,a:keyword . '\zs.*') != '-1'
	    let l:line=strpart(l:line,match(l:line,a:keyword . '\zs.*'))
	    let l:i+=1
	endwhile
    endif
    return l:i
endfunction
" }}}1
" {{{1 atplib#append 	/ at the end of a directory name
fun! atplib#append(where,what)
    return substitute(a:where,a:what . "\s*$",'','') . a:what
endfun
" }}}1
" {{{1 atplib#FindInputFiles 	/ find input files /
" this function is for complition of \bibliography and \input commands it returns a list
" of all files under a:dir and in g:outdir with a given extension.
function! atplib#FindInputFiles(dir,in_current_dir,ext)
	let l:raw_files=split(globpath(atplib#append(a:dir,'/'),'**'))
	if a:in_current_dir
	    call extend(l:raw_files,split(globpath(b:outdir,'*')))
	endif
" 	let b:raw=l:raw_files " DEBUG
	let l:file_list=[]
	for l:key in l:raw_files
	    if l:key =~ a:ext . '$'
		call add(l:file_list,l:key)
	    endif
	endfor
	return l:file_list
endfunction
" }}}1

" atplib#CheckClosed {{{1
" check if last bpat is closed.
" starting from the current line, limits the number of
" lines to search. It returns 0 if the environment is not closed or the line
" number where it is closed (an env is cannot be closed in 0 line)

" ToDo: the two function should only check not commented lines!
" ToDo: this do not works well with nested envs.
" Method 0 makes mistakes if the pattern is \begin:\end, if
" \begin{env_name}:\end{env_names} rather no (unless there are nested
" environments in the same name.
" Mechod 1 doesn't make mistakes and thus is preferable.
" after testing I shall remove method 0
function! atplib#CheckClosed(bpat,epat,line,limit,...)

"     NOTE: THIS IS MUCH FASTER !!! or SLOWER !!! ???            
"
"     let l:pos_saved=getpos(".") 
"     let l:cline=line(".")
"     if a:line != l:cline
" 	let l:col=len(getline(a:line))
" 	keepjumps call setpos(".",[0,a:line,l:col,0])
"     endif
"     let l:line=searchpair(a:bpat,'',a:epat,'nWr','',max([(a:line+a:limit),1]))
"     if a:line != l:cline
" 	keepjumps call setpos(".",l:pos_saved)
"     endif
"     return l:line


    if a:0 == 0 || a:1 == 0
	let l:method = 0
    else
	let l:method = a:1
    endif
"     echomsg "DEBUG METHOD " . l:method

    let l:len=len(getbufline(bufname("%"),1,'$'))
    let l:nr=a:line

    if a:limit == "$" || a:limit == "-1"
	let l:limit=l:len-a:line
    else
	let l:limit=a:limit
    endif

    if l:method==0
	while l:nr <= a:line+l:limit
	    let l:line=getline(l:nr)
" 	    if l:line =~ '\\def\|\%(re\)\?newcommand\>'
" 		let l:nr+=1
" 		continue
" 	    endif
" 	    echomsg "CC line " . l:nr . " " . l:line
	" Check if Closed
	    if l:nr == a:line
		if strpart(l:line,getpos(".")[2]-1) =~ '\%(' . a:bpat . '.*\)\@<!' . a:epat
" " 		    echo "CC 1 l:nr " . l:nr
		    return l:nr
		endif
	    else
		if l:line =~ '\%(' . a:epat . '.*\)\@<!' . a:bpat
		    return 0
		elseif l:line =~ '\%(' . a:bpat . '.*\)\@<!' . a:epat 
"     	    if l:line =~ a:epat 
		    return l:nr
		endif
	    endif
	    let l:nr+=1
	endwhile

    elseif l:method==1

	let l:bpat_count=0
	let l:epat_count=0
	let l:begin_line=getline(a:line)
	let l:begin_line_nr=line(a:line)
" 	echomsg "CC DEBUG ------------"
	while l:nr <= a:line+l:limit
	    let l:line=getline(l:nr)
" 	    if l:line =~ '\\def\|\%(re\)\?newcommand\>'
" 		let l:nr+=1
" 		continue
" 	    endif
	" I assume that the env is opened in the line before!
	    let l:bpat_count+=atplib#count(l:line,a:bpat,1)
	    let l:epat_count+=atplib#count(l:line,a:epat,1)
" 	    echomsg "cc line nr " . l:nr . " bpat " . l:bpat_count . " epat " . l:epat_count
	    if (l:bpat_count+1) == l:epat_count && l:begin_line !~ a:bpat
" 		echomsg "A"
		return l:nr
	    elseif l:bpat_count == l:epat_count && l:begin_line =~ a:bpat
" 		echomsg "B"
		return l:nr
	    endif 
	    let l:nr+=1
	endwhile
	return 0
    endif
endfunction
" }}}1
" atplib#CheckOpened {{{1
" Usage: By default (a:0 == 0 || a:1 == 0 ) it returns line number where the
" environment is opened if the environment is opened and is not closed (for
" completion), else it returns 0. However, if a:1 == 1 it returns line number
" where the environment is opened, if we are inside an environemt (it is
" openned and closed below the starting line or not closed at all), it if a:1
" = 2, it just check if env is opened without looking if it is closed (
" cursor position is important).
" a:1 == 0 first non closed
" a:1 == 2 first non closed by counting.

" this function doesn't check if sth is opened in lines which begins with '\\def\>'
" (some times one want's to have a command which opens an environment.

" Todo: write a faster function using searchpairpos() which returns correct
" values.
function! atplib#CheckOpened(bpat,epat,line,limit,...)


"     this is almost good:    
"     let l:line=searchpair(a:bpat,'',a:epat,'bnWr','',max([(a:line-a:limit),1]))
"     return l:line

    if a:0 == 0 || a:1 == 0
	let l:check_mode = 0
    elseif a:1 == 1
	let l:check_mode = 1
    elseif a:1 == 2
	let l:check_mode = 2
    endif

    let b:check_mode=l:check_mode

    let l:len=len(getbufline(bufname("%"),1,'$'))
    let l:nr=a:line

    if a:limit == "^" || a:limit == "-1"
	let l:limit=a:line-1
    else
	let l:limit=a:limit
    endif

    if l:check_mode == 0 || l:check_mode == 1
	while l:nr >= a:line-l:limit && l:nr >= 1
	    let l:line=getline(l:nr)
" 	    if l:line =~ '\\def\|\%(re\)\?newcommand\>'
" 		let l:nr-=1
" 		continue
" 	    endif
" 	echo "DEBUG A " . l:nr . " " . l:line
		if l:nr == a:line
" 		    let l:x= a:bpat . '.\{-}' . a:epat
" 		    echomsg " DEBUG CifO " . l:x
			if substitute(strpart(l:line,0,getpos(".")[2]), a:bpat . '.\{-}' . a:epat,'','g')
				    \ =~ a:bpat
			    let b:cifo_return=1
			    return l:nr
			endif
		else
		    if l:check_mode == 0
			if substitute(l:line, a:bpat . '.\{-}' . a:epat,'','g')
				    \ =~ a:bpat
			    " check if it is closed up to the place where we start. (There
			    " is no need to check after, it will be checked anyway
			    " b a seprate call in TabCompletion.
			    if !atplib#CheckClosed(a:bpat,a:epat,l:nr,a:limit,0)
					    " LAST CHANGE 1->0 above
				let b:cifo_return=2 . " " . l:nr 
				return l:nr
			    endif
			endif
		    elseif l:check_mode == 1
			if substitute(l:line, a:bpat . '.\{-}' . a:epat,'','g')
				    \ =~ '\%(\\def\|\%(re\)\?newcommand\)\@<!' . a:bpat
			    let l:check=atplib#CheckClosed(a:bpat,a:epat,l:nr,a:limit,1)
" 		    echo "DEBUG line nr: " l:nr . " line: " . l:line . " check: " . l:check
			    " if env is not closed or is closed after a:line
			    if  l:check == 0 || l:check >= a:line
				let b:cifo_return=2 . " " . l:nr 
				return l:nr
			    endif
			endif
		    endif
		endif
	    let l:nr-=1
	endwhile
    elseif l:check_mode == 2
	let l:bpat_count=0
	let l:epat_count=0
	let l:begin_line=getline(".")
	let l:c=0
	while l:nr >= a:line-l:limit  && l:nr >= 1
	    let l:line=getline(l:nr)
" 	    if l:line =~ '\\def\|\%(re\)\?newcommand\>'
" 		let l:nr-=1
" 		continue
" 	    endif
	" I assume that the env is opened in line before!
" 		let l:line=strpart(l:line,getpos(".")[2])
	    let l:bpat_count+=atplib#count(l:line,a:bpat,1)
	    let l:epat_count+=atplib#count(l:line,a:epat,1)
" 		echomsg "co " . l:c . " lnr " . l:nr . " bpat " . l:bpat_count . " epat " . l:epat_count
	    if l:bpat_count == (l:epat_count+1+l:c) && l:begin_line != line(".") 
		let l:env_name=matchstr(getline(l:nr),'\\begin{\zs[^}]*\ze}')
		let l:check=atplib#CheckClosed('\\begin{' . l:env_name . '}', '\\end{' . l:env_name . '}',1,a:limit,1)
" 			echomsg "co DEBUG " l:check . " env " . l:env_name
		if !l:check
		    return l:nr
		else
		    let l:c+=1
		endif
	    elseif l:bpat_count == l:epat_count && l:begin_line == line(".")
		return l:nr
	    endif 
	    let l:nr-=1
	endwhile
    endif
    return 0 
endfunction
" }}}1

" Test for new functions Check_if_... {{{1
" New functions!
" function! CC(bpat,epat,line,limit) 
"     let l:cline=line(".")
"     return searchpairpos(a:bpat,'',a:epat,'nW',(l:cline+a:limit),'!searchpair(a:bpat,"",a:epat,"bnW")')
" endfunction
" function! CO(bpat,epat,line,limit)
"     let l:cline=line(".")
"     let l:limit_line=max([(l:cline-a:limit),1])
"     return searchpairpos(a:bpat,'',a:epat,'bnW',l:limit_line,'!searchpair(a:bpat,"",a:epat,"nW")')
" endfunction
" }}}1

" atplib#CopyIndentation {{{1
function! atplib#CopyIndentation(line)
    let l:indent=split(a:line,'\s\zs')
    let l:eindent=""
    for l:s in l:indent
	if l:s =~ '^\%(\s\|\t\)'
	    let l:eindent.=l:s
	else
	    break
	endif
    endfor
    return l:eindent
endfunction
"}}}1
" atplib#CloseLastEnvironment {{{1
" the argument specifies if to use i or a (append before or after)
" default is to use i (before), so the cursor will be after.
" the second argument specifies which environment to close (without it tries
" checks which to close.
" ToDo: this would be nice if it worked with nested environments which starts in
" the same line (if starts in seprate lines the only thing to change is to
" move the cursor to the end of inserted closing).
" ToDo: add closing of other pairs {:},[:],\{:\} , \left:\right 
" ToDo: the mechanism closes:
" ToDo: closeing of !!!
" \begin{env}
" 	\begin{env}<Tab>
"
"
" \end{env}
" !!!this is important!!!
"
" \begin{theorem}
"       .....
"       <Tab>
" just under \begin{theorem}
" ToDo: Ad a highlight to messages!!! AND MAKE IT NOT DISAPEAR SOME HOW?
" (redrawing doesn't help). 
function! atplib#CloseLastEnvironment(...)

    if a:0 == 0 
	let l:com = 'i'
    elseif a:0 >= 1  && a:1 == 'a' 
	let l:com ='a'
    elseif  a:0 >= 1 && a:1 == 'i'
	let l:com = 'i'
    endif

    if a:0 >= 2
	let l:close=a:2
    endif
    if a:0 >= 3
	let l:env_name=a:3
    else
	let l:env_name="0"
    endif

    " ADD: if l:com == 'i' move before what we put.

"     let b:com=l:com "DEBUG

" {{{2 l:env_name
    if l:env_name == "0"
" 	let l:limit_toline=[1,1,1]
" 	let l:limit_toline[0]=max([1,(line(".")-g:atp_completion_limits[0])])
" 	let l:limit_toline[1]=max([1,(line(".")-g:atp_completion_limits[1])])
" 	let l:limit_toline[2]=max([1,(line(".")-g:atp_completion_limits[2])])
" 	let l:begin_line_env 	= searchpair('\%(%.*\)\@<!\\begin\s*{', '',
" 		    \ '\%(%.*\)\@<!\\end\s*{', 'bnW',l:limit_toline[2])
" 	let l:begin_line_dmath 	= searchpair(g:atp_math_modes[1][0],'',g:atp_math_modes[1][1], 'bnW',"",l:limit_toline[1])
" 	let l:begin_line_imath 	= searchpair(g:atp_math_modes[0][0],'',g:atp_math_modes[0][1], 'bnW',"",l:limit_toline[0])
"       My atplib#CheckOpened function is much faster !!!
	let l:begin_line_env 	= atplib#CheckOpened('\%(%.*\)\@<!\\begin\s*{',
		    \ '\%(%.*\)\@<!\\end\s*{',line("."),g:atp_completion_limits[2])
	let l:begin_line_dmath 	= atplib#CheckOpened(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line("."),g:atp_completion_limits[1])
	let l:begin_line_imath 	= atplib#CheckOpened(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line("."),g:atp_completion_limits[0])
    else
	let l:begin_line 	= searchpair('\%(%.*\)\@<!\\begin\s*{' . l:env_name , '', 
		    \ '\%(%.*\)\@<!\\end\s*{' . l:env_name, 'bnW')
    endif
"}}}2

"{{{2 a:0
    if a:0 <= 1
	let l:begin_line=max([ l:begin_line_env, l:begin_line_imath, l:begin_line_dmath])
" 	echo "OK"
    elseif a:0 <= 2 && l:close == "environment"
" 	echo "env"
	let l:begin_line = l:begin_line_env
    elseif a:0 <= 2 && l:close == "displayed_math"
" 	echo "disp"
	let l:begin_line = l:begin_line_dmath
    elseif a:0 <= 2 && l:close == "inline_math"
" 	echo "inl"
	let l:begin_line = l:begin_line_imath
    endif

    if a:0 < 2
	if l:begin_line_env >= l:begin_line_dmath && l:begin_line_env >= l:begin_line_imath
	    let l:close='environment'
	elseif l:begin_line_dmath > l:begin_line_env && l:begin_line_dmath > l:begin_line_imath
	    let l:close='displayed_math'
	else
	    let l:close='inline_math'
	endif
    endif

    " regardles of a:2 if a:3 is given:
    if a:0 == 3
	let l:close='environment'
    endif
    let b:close=l:close " DEBUG
    let b:begin_line=l:begin_line "DEBUG
"}}}2

    "{{{2 if l:begin_line == 1
    if l:begin_line
	let l:line=getline(l:begin_line)
	let l:cline=getline(".")
	if l:close == 'environment'
	    if l:env_name == 0
		let l:env = matchstr(l:line, '\%(\\begin\s*{[^}]*}\s*\%(\|{[^]*}\|([^)])\)\{,2}\s*\%(\\label\s*{[^}]*}\)\?\)*\s*\\begin{\zs[^}]*\ze}\%(.*\\begin\s{\)\@!')
	    else
		let l:env=l:env_name
	    endif
	endif
	let l:pos=getpos(".")
	" Copy the intendation of what we are closing.
	let l:eindent=atplib#CopyIndentation(l:line)

	" Rules:
	" env & \[ \]: close in the same line 
	" unless it starts in a seprate line,
	" \( \): close in the same line. 
	"{{{3 l:close == environment
	if (l:close == 'environment' 
		    \ && l:line !~ '^\s*\%(\$\|\$\$\|[^\\]\\(\|[^\\]\\\[\)\?\s*\\begin\s*{[^}]*}\s*\%(([^)]*)\s*\|{[^}]*}\s*\|\[[^\]]*\]\s*\)\{,3}\%(\\label{[^}]*}\s*\)\?$') ||
		    \ (l:close == 'displayed_math' && l:line !~ '^\s*[^\\]\\\[\s*$' ) ||
		    \ (l:close == 'inline_math' && (l:line !~ '^\s*[^\\]\\(\s*$' || l:begin_line == line(".") )) 

" 		    \ && l:line !~ '^\s*\%(\$\|\$\$\|[^\\]\\(\|[^\\]\\\[\)\?\s*\\begin\s*{\%(array\|tabular\)}\%(\s*{[^}]*}\)\?\s*$' ) ||
	    " the above condition matches for the situations when we have to
	    " complete in the same line in three cases:
	    " l:close == environment, displayd_math or inline_math. 

	    " do not complete environments which starts in a definition.
" let b:cle_debug= (getline(l:begin_line) =~ '\\def\|\%(re\)\?newcommand') . " " . (l:begin_line != line("."))
	    if getline(l:begin_line) =~ '\\def\|\%(re\)\?newcommand' && l:begin_line != line(".")
" 		let b:cle_return="def"
		return b:cle_return
	    endif
	    "{{{4 
	    if l:close == 'environment' && index(g:atp_no_complete,l:env) == '-1' &&
		\ !atplib#CheckClosed('\%(%.*\)\@<!\\begin\s*{' . l:env,'\%(%.*\)\@<!\\end\s*{' . l:env,line("."),g:atp_completion_limits[2])
		if l:com == 'a'  
		    call setline(line("."), strpart(l:cline,0,getpos(".")[2]) . '\end{'.l:env.'}' . strpart(l:cline,getpos(".")[2]))
		    let l:pos=getpos(".")
		    let l:pos[2]=len(strpart(l:cline,0,getpos(".")[2]) . '\end{'.l:env.'}')+1
		    keepjumps call setpos(".",l:pos)
		else
		    call setline(line("."), strpart(l:cline,0,getpos(".")[2]-1) . '\end{'.l:env.'}' . strpart(l:cline,getpos(".")[2]-1))
		    let l:pos=getpos(".")
		    let l:pos[2]=len(strpart(l:cline,0,getpos(".")[2]-1) . '\end{'.l:env.'}')+1
		    keepjumps call setpos(".",l:pos)
		endif
	    "}}}4
	    "{{{4
	    elseif l:close == 'displayed_math' && !atplib#CheckClosed(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line("."),g:atp_completion_limits[1])
		if l:com == 'a' 
		    if getline(l:begin_line) =~ '^\s*\\\[\s*$'
			call append(line("."),atplib#CopyIndentation(getline(l:begin_line)).'\]')
		    else
			call setline(line("."), strpart(l:cline,0,getpos(".")[2]) . '\]'. strpart(l:cline,getpos(".")[2]))
		    endif
		else
		    if getline(l:begin_line) =~ '^\s*\\\[\s*$'
			call append(line("."),atplib#CopyIndentation(getline(l:begin_line)).'\]')
		    else
			call setline(line("."), strpart(l:cline,0,getpos(".")[2]-1) . '\]'. strpart(l:cline,getpos(".")[2]-1))
" TODO: This could be optional: (but the option rather
" should be an argument of this function rather than
" here!
		    endif
		    let l:pos=getpos(".")
		    let l:pos[2]+=2
		    keepjumps call setpos(("."),l:pos)
" 		    let b:cle_return="displayed math"
		endif
	    "}}}4
	    "{{{4
	    elseif l:close == 'inline_math' && !atplib#CheckClosed(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line("."),g:atp_completion_limits[1])
" 		exec "normal " . l:com  . "\\)"
		if l:com == 'a'
		    call setline(line("."), strpart(l:cline,0,getpos(".")[2]) . '\)'. strpart(l:cline,getpos(".")[2]))
		else
		    call setline(line("."), strpart(l:cline,0,getpos(".")[2]-1) . '\)'. strpart(l:cline,getpos(".")[2]-1))
		    let l:pos=getpos(".")
		    let l:pos[2]+=2
		    keepjumps call setpos(("."),l:pos)
" 		    let b:cle_return="X"
		endif
	    endif
	    "}}}4
	"}}}3
	else "{{{3 
	" We are closing in a new line, preerving the indentation.
	    
	    let l:line_nr=line(".")

	    "Debug:
	    if l:close == 'environment'
	    " NESTING
		" do not complete environments which starts in a definition.

		let l:error=0
		let l:prev_line_nr="-1"
		let l:cenv_lines=[]
		let l:nr=line(".")
		" l:line_nr number of line which we complete
		" l:cenv_lines list of closed environments (we complete after
		" line number maximum of these numbers.
" 		echomsg "DEBUG ----------"

		let l:pos=getpos(".")
		let l:pos_saved=deepcopy(l:pos)

		while l:line_nr >= 0
			let l:line_nr=search('\%(%.*\)\@<!\\begin\s*{','bW')
		    " match last environment openned in this line.
		    " ToDo: afterwards we can make it works for multiple openned
		    " envs.
		    let l:env_name=matchstr(getline(l:line_nr),'\%(%.*\)\@<!\\begin\s*{\zs[^}]*\ze}\%(.*\\begin\s*{[^}]*}\)\@!')
		    if index(g:atp_long_environments,l:env_name) != -1
			let l:limit=3
		    else
			let l:limit=2
		    endif
		    let l:close_line_nr=atplib#CheckClosed('\%(%.*\)\@<!\\begin\s*{' . l:env_name, 
				\ '\%(%.*\)\@<!\\end\s*{' . l:env_name,
				\ l:line_nr,g:atp_completion_limits[l:limit],1)
" 		    echomsg "CLE line_nr " . l:line_nr . " close_line_nr " . l:close_line_nr . " env_name " . l:env_name . " " . g:atp_completion_limits[l:limit]

		    if l:close_line_nr != 0
			call add(l:cenv_lines,l:close_line_nr)
		    else
			break
		    endif
		    let l:line_nr-=1
" 		    echo "CLE DEBUG l:line_nr " . l:line_nr
		endwhile

" 		if g:atp_close_after_last_closed == 1	
		    keepjumps call setpos(".",l:pos)
" 		endif
		    
" 		let b:cenv_lines=deepcopy(l:cenv_lines) " DEBUG
" 		let b:line_nr=l:line_nr " DEBUG
			
		if getline(l:line_nr) =~ '\%(%.*\)\@<!\%(\\def\|\%(re\)\?newcommand\)' && l:line_nr != line(".")
" 		    let b:cle_return="def"
		    return
		endif
		" get all names of environments which begin in this line
		let l:env_names=[]
		let l:line=getline(l:line_nr)
		while l:line =~ '\\begin\s*{' 
		    let l:cenv_begins = match(l:line,'\%(%.*\)\@<!\\begin{\zs[^}]*\ze}\%(.*\\begin\s{\)\@!')
		    let l:cenv_name = matchstr(l:line,'\%(%.*\)\@<!\\begin{\zs[^}]*\ze}\%(.*\\begin\s{\)\@!')
		    let l:cenv_len=len(l:cenv_name)
		    let l:line=strpart(l:line,l:cenv_begins+l:cenv_len)
		    call add(l:env_names,l:cenv_name)
			" DEBUG:
" 			let b:env_names=l:env_names
" 			let b:line=l:line
" 			let b:cenv_begins=l:cenv_begins
" 			let b:cenv_name=l:cenv_name
		endwhile
		" thus we have a list of env names.
		
		" make a dictionary of lines where they closes. 
		" this is a list of pairs (I need the order!)
		let l:env_dict=[]
" 		let b:env_dict=l:env_dict " DEBUG
		" list of closed environments
		let l:cenv_names=[]
" 		let b:cenv_names=l:cenv_names
		for l:uenv in l:env_names
		    let l:uline_nr=atplib#CheckClosed('\%(%.*\)\@<!\\begin\s*{' . l:uenv . '}', 
				\ '\%(%.*\)\@<!\\end\s*{' . l:uenv . '}', l:line_nr, g:atp_completion_limits[2])
		    call extend(l:env_dict,[ l:uenv, l:uline_nr])
		    if l:uline_nr != '0'
			call add(l:cenv_names,l:uenv)
		    endif
		endfor
		
		" close unclosed environment

		" check if at least one of them is closed
		if len(l:cenv_names) == 0
" 		    echomsg "cle DEBUG A1"
		    let l:str=""
		    for l:uenv in l:env_names
			if index(g:atp_no_complete,l:uenv) == '-1'
			    let l:str.='\end{' . l:uenv .'}'
			endif
		    endfor
		    " l:uenv will remain the last environment name which
		    " I use!
		    " Do not append empty lines (l:str is empty if all l:uenv
		    " belongs to the g:atp_no_complete list.
		    if len(l:str) == 0
			return 0
		    endif
" 		    let b:str=l:str " DEBUG
		    let l:eindent=atplib#CopyIndentation(getline(l:line_nr))
		    let l:pos=getpos(".")
		    if len(l:cenv_lines) > 0 
" 			call append(max(l:cenv_lines), l:eindent . l:str)

			let l:max=max(l:cenv_lines)
			let l:pos[1]=l:max+1
			" find the first closed item below the last closed
			" pair (below l:pos[1]). (I assume every env is in
			" a seprate line!
" 			let l:end=atplib#CheckClosed('\\begin\s*{','\\end\s*{',max(l:cenv_lines)+1,g:atp_completion_limits[2],1)
			let l:end=atplib#CheckClosed('\%(%.*\)\@<!\\begin\s*{','\%(%.*\)\@<!\\end\s*{',l:line_nr,g:atp_completion_limits[2],1)
			let b:info= " l:max=".l:max." l:end=".l:end." line('.')=".line(".")." l:line_nr=".l:line_nr
			" if the line was found append just befor it.
			echohl WarningMsg 
			if l:end != 0 
				if line(".") <= l:max
				    if line(".") <= l:end
					call append(l:max, l:eindent . l:str)
					echomsg l:str . " appneded after line " . l:end
" 					let b:cle_return="append cenv_lines 1.1.1 before line " . l:max 
					call setpos(".",[0,l:max+1,len(l:eindent.l:str)+1,0])
				    else
					call append(l:end-1, l:eindent . l:str)
					echomsg l:str . " appneded after line " . l:end
" 					let b:cle_return="append cenv_lines 1.1.2 before line " . l:max 
					call setpos(".",[0,l:end,len(l:eindent.l:str)+1,0])
				    endif
				elseif line(".") < l:end
				    call append(line("."), l:eindent . l:str)
				    echomsg l:str . " appneded after line " . line(".")
" 				    let b:cle_return="append cenv_lines 1.2 before line " . line(".")
				    call setpos(".",[0,line(".")+1,len(l:eindent.l:str)+1,0])
				elseif line(".") >= l:end
				    call append(l:end-1, l:eindent . l:str)
				    echomsg l:str . " appneded after line " . (l:end-1)
" 				    let b:cle_return="append cenv_lines 1.3 before line " . (l:end-1)
				    call setpos(".",[0,l:end,len(l:eindent.l:str)+1,0])
				endif
			else
			    if line(".") >= l:max
				call append(l:pos_saved[1], l:eindent . l:str)
				keepjumps call setpos(".",l:pos_saved)
				echomsg l:str . " appneded after line " . line(".")
" 				let b:cle_return="append cenv_lines 2.1 after line " . line(".")
				call setpos(".",[0,l:pos_saved[1]+1,len(l:eindent.l:str)+1,0])
			    elseif line(".") < l:max
				call append(l:max, l:eindent . l:str)
				echomsg l:str . " appneded after line " . l:max
" 				let b:cle_return="append cenv_lines 2.2 after line " . l:max
				call setpos(".",[0,l:max+1,len(l:eindent.l:str)+1,0])
" 			    elseif line(".") >= l:end
"				If we are to far				
" 				call append(l:end-1, l:eindent . l:str)
" 				echomsg l:str . " appneded after line " . (l:end-1)
" 				let b:cle_return="append cenv_lines 2.3 before line " . (l:end-1)
			    endif
			endif
			echohl None 
		    else
			let l:pos[1]=l:line_nr
			let l:pos[2]=1
			" put cursor at the end of the line where not closed \begin was
			" found
			keepjumps call setpos(".",[0,l:line_nr,len(getline(l:line_nr)),0])
			" and find first not matching \end.
			let l:iline=searchpair('\\begin{','','\\end{','nW')
			let l:cline=getline(l:pos_saved[1])
" 			let b:iline=l:iline
" 			let b:cline=l:cline
" 			if l:cline !~ '^\s*$'
			if l:iline > l:line_nr && l:iline <= l:pos_saved[1]
			    call append(l:iline-1, l:eindent . l:str)
			    echomsg l:str . " appneded before line " . l:iline
" 			    let b:cle_return="append before if 3.1 str " . l:str . " before line " . l:iline
			    let l:pos_saved[2]+=len(l:str)
			    call setpos(".",[0,l:iline,len(l:eindent.l:str)+1,0])
			else
			    if l:cline =~ '\\begin{\%('.l:uenv.'\)\@!'
				call append(l:pos_saved[1]-1, l:eindent . l:str)
				echomsg l:str . " appneded before line " . l:pos_saved[1]
" 				let b:cle_return="append before if 3.2.1 str " . l:str . " before line " . l:pos_saved[1] 
				let l:pos_saved[2]+=len(l:str)
				call setpos(".",[0,l:pos_saved[1],len(l:eindent.l:str)+1,0])
			    else
				call append(l:pos_saved[1], l:eindent . l:str)
				echomsg l:str . " appneded after line " . l:pos_saved[1]
" 				let b:cle_return="append after if 3.2.2 str " . l:str . " after line " . l:pos_saved[1] 
				let l:pos_saved[2]+=len(l:str)
				call setpos(".",[0,l:pos_saved[1]+1,len(l:eindent.l:str)+1,0])
			    endif
			endif 
			return 1
		    endif
		else
		    return "this is too hard?"
		endif
		unlet! l:env_names
		unlet! l:env_dict
		unlet! l:cenv_names
		unlet! l:pos 
		unlet! l:pos_saved
" 		if getline('.') =~ '^\s*$'
" 		    exec "normal dd"
" 		endif
	    elseif  l:close == 'displayed_math'
		let l:iline=line(".")
		" if the current line is empty append before it.
		if getline(".") =~ '^\s*$' && l:iline > 1
		    let l:iline-=1
		endif
		call append(l:iline, l:eindent . '\]')
		echomsg "\[ closed in line " . l:iline
" 		let b:cle_return=2 . " dispalyed math " . l:iline  . " indent " . len(l:eindent)" DEBUG
	    elseif l:close == 'inline_math'
		let l:iline=line(".")
		" if the current line is empty append before it.
		if getline(".") =~ '^\s*$' && l:iline > 1
		    let l:iline-=1
		endif
		call append(l:iline, l:eindent . '\)')
		echomsg "\( closed in line " . l:iline
" 		let b:cle_return=2 . " inline math " . l:iline . " indent " .len(l:eindent) " DEBUG
	    endif
	    return ''
	endif
	"}}}3
" 	" preserve the intendation
" 	if getline(line(".")) =~ '^\s\+\\end{'
" 	    call setline(line("."),substitute(getline(line(".")),'^\s*',l:eindent,''))
" 	    echomsg "DEBUG: WHAT's THAT?"
" 	endif
    endif
    "}}}2
endfunction
" imap <F7> <Esc>:call atplib#CloseLastEnvironment()<CR>
" }}}1
" {{{1 atplib#CloseLastBracket
"
" Note adding a bracket pair doesn't mean that it will be supported!
" This is to be done! and is quite easy.

" Notes: it first closes the most outer opened bracket:
" 	\left\{\Bigl( 
" 	will first close with \right\} and then \Bigl)
" it still doesn't work 100% well with nested brackets (the part that remains is to
" close in right place) But is doesn't close closed pairs !!! 

" ToDo: \\{ is not closing right, add support for {:}!
" {{{2 			atplib#CloseLastBracket	
function! atplib#CloseLastBracket()
    " {{{3
    let l:pattern=""
    let l:size_patterns=[]
    for l:size in keys(g:atp_sizes_of_brackets)
	call add(l:size_patterns,escape(l:size,'\'))
    endfor
    let l:pattern 	= '\%('.join(l:size_patterns,'\|').'\)\?'
    let l:pattern_b	= '\%('.join(l:size_patterns,'\|').'\)'
    let l:pattern_o	= '\(\\\@<!(\|\\{\|\\\@<![\|\\\@<!{\)'
    let l:pattern_c	= '\(\\\@<!)\|\\}\|\\\@<!]\|\\\@<!{\)'


    let l:limit_line=max([1,(line(".")-g:atp_completion_limits[1])])
"    let l:open_line=atplib#CheckOpened(
" 	       \ l:pattern_o, l:pattern_c,
" 	       \ line("."),g:atp_completion_limits[0],1)
"    let l:close_line=atplib#CheckClosed(
" 	       \ l:pattern_o, l:pattern_c,
" 	       \ line("."),g:atp_completion_limits[0],1)
        
   let l:pair_1=searchpairpos('\\\@<!(','','\\\@<!)','bnW',"",l:limit_line)
   let l:pair_2=searchpairpos('\\{','','\\}','bnW',"",l:limit_line)
   let l:pair_3=searchpairpos('\\\@<!\[','','\\\@<!\]','bnW',"",l:limit_line)
   let l:pair_4=searchpairpos('\\\@<!{','','\\\@<!}','bnW',"",l:limit_line)
   let l:pos_saved=getpos(".")

   " DEBUG:
"    for i in ['1', '2', '3', '4']
"        let b:pair_{i}=l:pair_{i}
"    endfor

   " But mayby we shouldn't check if the bracket is closed sometimes one can
   " want to close closed bracket and delete the old one.
   "
   " just add check if the given b:pair_123 are closed or not and take the max
   " over not closed pairs. 
   
   "    change the position! and then: 
   "    check the flag 'r' in searchpair!!!
   let l:pos=deepcopy(l:pos_saved)
   let l:pos[1]=l:pair_1[0]
   let l:pos[2]=l:pair_1[1]
   keepjumps call setpos(".",l:pos)
   let l:check_1= atplib#CheckClosed('\\\@<!(','\\\@<!)',line("."),g:atp_completion_limits[0],1) == '0'
   let l:pos[1]=l:pair_2[0]
   let l:pos[2]=l:pair_2[1]
   keepjumps call setpos(".",l:pos)
   let l:check_2= atplib#CheckClosed('\\{','\\}',line("."),g:atp_completion_limits[0],1) == '0'
   let l:pos[1]=l:pair_3[0]
   let l:pos[2]=l:pair_3[1]
   keepjumps call setpos(".",l:pos)
   let l:check_3= atplib#CheckClosed('\\\@<![','\\\@<!]',line("."),g:atp_completion_limits[0],1) == '0'
   let l:pos[1]=l:pair_4[0]
   let l:pos[2]=l:pair_4[1]
   keepjumps call setpos(".",l:pos)
   let l:check_4= atplib#CheckClosed('\\\@<!{','\\\@<!}',line("."),g:atp_completion_limits[0],1) == '0'
   keepjumps call setpos(".",l:pos_saved)
   
   " DEBUG:
"    for i in ['1', '2', '3', '4']
"        let b:check_{i}=l:check_{i}
"    endfor

   let l:open_col=max([(l:pair_1[1]*l:check_1),(l:pair_2[1]*l:check_2),(l:pair_3[1]*l:check_3),(l:pair_4[1]*l:check_4)])
   if l:open_col == l:pair_1[1] && l:check_1 != 0 
       let l:open_line=l:pair_1[0]
   elseif l:open_col == l:pair_2[1] && l:check_2 != 0 
       let l:open_line=l:pair_2[0]
   elseif l:open_col == l:pair_3[1] && l:check_3 != 0 
       let l:open_line=l:pair_3[0]
   elseif l:open_col == l:pair_4[1] && l:check_4 != 0 
       let l:open_line=l:pair_4[0]
   endif


   " Debug:
"        let b:open_line=l:open_line
"        let b:open_col=l:open_col 

    "}}}3
    " {{{3 main if
   if l:open_col 
"    if l:open_col && !l:close_line
	let l:line=getline(l:open_line)

	let l:bline=strpart(l:line,0,(l:open_col-1))
	let l:eline=strpart(l:line,l:open_col-1,2)


	let l:opening_size=matchstr(l:bline,'\zs'.l:pattern_b.'\ze\s*$')
	let l:closing_size=get(g:atp_sizes_of_brackets,l:opening_size,"")
	let l:opening_bracket=matchstr(l:eline,'^'.l:pattern_o)

	" DEBUG:
" 	let b:o_bra=l:opening_bracket
" 	let b:o_size=l:opening_size
" 	let b:bline=l:bline
" 	let b:eline=l:eline

	if l:line =~ escape(l:opening_size.l:opening_bracket,'\') . '\s*$' && col(".") == len(getline(line(".")))
	    let l:indent=CopyIndentation(getline(l:open_line))
	    call append(line("."),l:indent.l:closing_size.get(g:atp_bracket_dict,l:opening_bracket))
" 	    let b:clb_return='append end line'
	    return 'append end line'
	else
	    let l:cline=getline(line("."))
	    if mode() == 'i'
		call setline(line("."), strpart(l:cline,0,getpos(".")[2]-1).
			\ l:closing_size.get(g:atp_bracket_dict,l:opening_bracket) . 
			\ strpart(l:cline,getpos(".")[2]-1))
	    elseif mode() == 'n'
		call setline(line("."), strpart(l:cline,0,getpos(".")[2]).
			\ l:closing_size.get(g:atp_bracket_dict,l:opening_bracket) . 
			\ strpart(l:cline,getpos(".")[2]))
	    endif
	    let l:pos=getpos(".")
	    let l:pos[2]+=len(l:closing_size.get(g:atp_bracket_dict,l:opening_bracket))
	    keepjumps call setpos(".",l:pos)
" 	    let b:clb_return='close inline'
	    return 'close inline'
	endif
   endif
   " }}}3
endfunction
" }}}2
" }}}1

" atplib#SearchPackage {{{1
"
" This function searches if the package in question is declared or not.
" Returns 1 if it is and 0 if it is not.
" It was inspired by autex function written by Carl Mueller, math at carlm e4ward c o m
" name = package name (tikz library name)
" a:1  = stop line (number of the line \\begin{document} 
" a:2  = pattern matching the command (without '^[^%]*\\', just the name)
" to match \usetikzlibrary{...,..., - 
function! atplib#SearchPackage(name,...)

    let l:pos_saved=getpos(".")

    if a:0 >= 1
	if a:1 != 0
	    let l:stop_line=a:1
	else
	    keepjumps call setpos(".", [0,1,1,0])
	    let l:stop_line=search('\\begin\s*{document}','nW')
	endif
    endif

    if a:0 == 2
	let l:command=a:2
    else
	let l:command='usepackage\s*\%(\[[^]]*]\)\?'
    endif

    if l:stop_line != 0

	keepjumps call setpos(".",[0,1,1,0])
	let l:return=search('^[^%]*\\'.l:command."\s*{[^}]*".a:name,'ncW',l:stop_line)

	keepjump call setpos(".",l:pos_saved)
	return l:return

    else

	keepjumps call setpos(".",[0,1,1,0])
	let l:return=search('^[^%]*\\'.l:command."\s*{[^}]*".a:name,'ncW')

	keepjump call setpos(".",l:pos_saved)
	return l:return

    endif

endfunction
" {{{2 old function 
" function! atplib#Search_Package(name,...)
"     if a:0 == 0
" 	let l:command='usepackage\s*\%(\[[^]]*]\)\?'
"     elseif a:0 == 1
" 	let l:command=a:1
"     else
" 	let l:command='usepackage\s*\%(\[[^]]*]\)\?'
"     endif
" 	
"     if a:0 == 2
" 	let l:command=a:2
"     endif
" 
"     let l:n=1
"     let l:bufnr=bufnr(b:atp_mainfile)
"     let l:line=join(getbufline(l:bufnr,l:n))
" "     echo "DEBUG SEARCH PACKAGE " . l:line  . " bufnr " . l:bufnr . " pattern " . '^[^%]*\\\<'.l:command.'\>\s*{.*' . a:name
"     let l:len=len(getbufline(l:bufnr,1,'$'))
"     while l:line !~ '\\begin\s*{document}' &&  l:n <= l:len
" 	if l:line =~ '^[^%]*\\\<'.l:command.'\s*{.*' . a:name
" 	    return 1
" 	endif
" 	let l:n+=1
" 	let l:line=join(getbufline(l:bufnr,l:n))
"     endwhile
"     return 0
" endfunction " }}}2
" }}}1
" atplib#DocumentClass {{{1
function! atplib#DocumentClass()

    let l:bufnr=bufnr(b:atp_mainfile)

    let l:n=1
    let l:line=join(getbufline(l:bufnr,l:n))

    if l:line =~ '\\documentclass'
" 	let b:line=l:line " DEBUG
	return substitute(l:line,'.*\\documentclass\s*\%(\[.*\]\)\?{\(.*\)}.*','\1','')
    endif
    while l:line !~ '\\documentclass'
	if l:line =~ '\\documentclass'
	    return substitute(l:line,'.*\\documentclass\s*\%(\[.*\]\)\?{\(.*\)}.*','\1','')
	endif
	let l:n+=1
	let l:line=join(getbufline(l:bufnr,l:n))
    endwhile
endfunction
" }}}1
" {{{1 atplib#FindFiles 	/ find files: bst, cls, etc ... /
function! atplib#FindFiles(format,ext)
    let l:path=substitute(substitute(system("kpsewhich -show-path ".a:format ),'!!','','g'),'\/\/\+','\/','g')
"     let b:path=l:path
    let l:path=substitute(l:path,':\|\n',',','g')
    let l:list=split(globpath(l:path,"**/*.".a:ext),'\n') 
    call map(l:list,'fnamemodify(v:val,":t:r")')
    return l:list
endfunction
" }}}1
" atplib#Extend {{{1
" arguments are the same as for extend(), but it adds only the entries which
" are not present.
function! atplib#Extend(list_a,list_b,...)
    let l:list_a=deepcopy(a:list_a)
    let l:diff=[]

    for l:b in a:list_b
	if index(a:list_a,l:b) == '-1'
	    call add(l:diff, l:b)
	endif
    endfor
    if a:0 == 0
	return extend(l:list_a,l:diff)
    else
	return extend(l:list_a,l:diff,a:1)
    endif
endfunction
" }}}1
" {{{1 atplib#Add
function! atplib#Add(list,what)
    let l:new=[] 
    for l:el in a:list
	call add(l:new,l:el . a:what)
    endfor
    return l:new
endfunction
"}}}1

" atplib#TabCompletion {{{1
" This is the main TAB COMPLITION function.
"
" expert_mode = 1 (on)  gives less completions in some cases (commands,...)
" 			the matching pattern has to match at the begining and
" 			is case sensitive. Furthermode  in expert mode, if
" 			completing a command and found less than 1 match then
" 			the function tries to close \(:\) or \[:\] (but not an
" 			environment, before doing ToDo in line 3832 there is
" 			no sense to make it).
" 			<Tab> or <F7> (if g:atp_no_tab_map=1)
" expert_mode = 0 (off) gives more matches but in some cases better ones, the
" 			string has to match somewhare and is case in
" 			sensitive, for example:
" 			\arrow<Tab> will show all the arrows definded in tex,
" 			in expert mode there would be no match (as there is no
" 			command in tex which begins with \arrow).
" 			<S-Tab> or <S-F7> (if g:atp_no_tab_map=1)
"
" ToDo: \ref{<Tab> do not closes the '}', its by purpose, as sometimes one
" wants to add more than one reference. But this is not allowed by this
" command! :) I can add it.
" Completion Modes:
" 	documentclass (\documentclass)
" 	labels   (\ref,\eqref)
" 	packages (\usepackage)
" 	commands
" 	environments (\begin,\(:\),\[:\])
" 	brackets ((:),[:],{:}) preserves the size operators!
" 	bibitems (\cite)
" 	bibfiles (\bibliography)
" 	bibstyle (\bibliographystyle)
" 	end	 (close \begin{env} with \end{env})
"

"ToDo: the completion should be only done if the completed text is different
"from what it is. But it might be as it is, there are reasons to keep this.
"
"
"TODO: g:atp_check_if_opened problem: \(\right<Tab>
"TODO: cite when thepattern was not found it just closes the bracket, it
"should do nothing or warn that the pattern was not found.
"ToTHINK: g:atp_commands add g:atp_math_commands, Do add g:atp_commands in math mode /when g:atp_check_if_open=1/ ?) 
function! atplib#TabCompletion(expert_mode,...)
    " {{{2 Match the completed word 
    let l:normal_mode=0
    if a:0 >= 1
	let l:normal_mode=a:1
    endif

    " this specifies the default argument for atplib#CloseLastEnvironment()
    " in some cases it is better to append after than before.
    let b:append='i'

    let l:pos=getpos(".")
    let l:pos_saved=deepcopy(l:pos)
    let l:line=join(getbufline("%",l:pos[1]))
    let l:nchar=strpart(l:line,l:pos[2]-1,1)
"     let b:nchar=l:nchar " debug
    let l:l=strpart(l:line,0,l:pos[2]-1)
    let b:l=l:l	" debug
    let l:n=strridx(l:l,'{')
    let l:m=strridx(l:l,',')
    let l:o=strridx(l:l,'\')
    let l:s=strridx(l:l,' ')
    let l:p=strridx(l:l,'[')
     
"     DEBUG:
"     let b:n=l:n
"     let b:o=l:o
"     let b:s=l:s
"     let b:p=l:p

    let l:nr=max([l:n,l:m,l:o,l:s,l:p])
    " this matches for \...
    let l:begin=strpart(l:l,l:nr+1)
    let l:cbegin=strpart(l:l,l:nr)
    " and this for '\<\w*$' (begining of last started word) -- used in
    " tikzpicture completion method 
    let l:tbegin=matchstr(l:l,'\zs\<\w*$')
    let l:obegin=strpart(l:l,l:o)

    let b:tbegin=l:tbegin " DEBUG
    let b:obegin=l:obegin " DEBUG
    let b:begin= l:begin  " DEBUG

    " what we are trying to complete: usepackage, environment.
    let l:pline=strpart(l:l,0,l:nr)
    let b:pline=l:pline	"DEBUG

    let l:limit_line=max([1,(l:pos[1]-g:atp_completion_limits[1])])
"     let l:pair_1=searchpairpos('\\\@<!(', '', '\\\@<!)', 'bnW', "", l:limit_line)
"     let l:pair_2=searchpairpos('\\{',	  '', '\\}',	 'bnW', "", l:limit_line)
"     let l:pair_3=searchpairpos('\\\[',	  '', '\\\]',	 'bnW', "", l:limit_line)
" }}}2
" {{{2 SET COMPLETION METHOD
    " {{{3 command
    if l:o > l:n && l:o > l:s && 
	\ l:pline !~ '\%(input\|include\%(only\)\?\|[^\\]\\\\[^\\]$\)' &&
	\ l:begin !~ '{\|}\|,\|-\|\^\|\$\|(\|)\|&\|-\|+\|=\|#\|:\|;\|\.\|,\||\|?$' &&
	\ l:begin !~ '^\[\|\]\|-\|{\|}\|(\|)' &&
	\ l:cbegin =~ '^\\' && !l:normal_mode &&
	\ l:l !~ '\\cite{[^}]*$' 

	" in this case we are completeing a command
	" the last match are the things which for sure do not ends any
	" command. The pattern '[^\\]\\\\[^\\]$' do not matches "\" and "\\\",
	" in which case the line contains "\\" and "\\\\" ( = line ends!)
	" (here "\" is one character \ not like in magic patterns '\\')
	" but matches "" and "\\" (i.e. when completing "\" or "\\\" [end line
	" + command].
	if index(g:atp_completion_active_modes, 'commands') != -1
	    let l:completion_method='command'
	    "DEBUG:
	    let b:comp_method='command'
	else
" 	    let b:comp_method='command fast return'
	    return ''
	endif
    "}}}3
    "{{{3 environment names
    elseif (l:pline =~ '\%(\\begin\|\\end\)\s*$' && l:begin !~ '}.*$' && !l:normal_mode)
	if index(g:atp_completion_active_modes, 'environment names') != -1 
	    let l:completion_method='environment_names'
	    "DEBUG:
	    let b:comp_method='environment_names'
	else
" 	    let b:comp_method='environment_names fast return'
	    return ''
	endif
    "}}}3
    "{{{3 close environments
    elseif !l:normal_mode && 
		\ ((l:pline =~ '\\begin\s*$' && l:begin =~ '}\s*$') || ( l:pline =~ '\\begin\s*{[^}]*}\s*\\label' ) ) || 
		\ l:normal_mode && l:pline =~ '\\begin\s*\({[^}]*}\?\)\?\s*$'
	if (!l:normal_mode && index(g:atp_completion_active_modes, 'close environments') != -1 ) ||
		    \ (l:normal_mode && index(g:atp_completion_active_modes_normal_mode, 'close environments') != -1 )
	    let l:completion_method='close environments'
	    "DEBUG:
	    let b:comp_method='colse environments'
	else
	    let b:comp_method='colse environments fast return'
	    return ''
	endif
    "}}}3
    "{{{3 label
    elseif l:pline =~ '\\\%(eq\)\?ref\s*$' && !l:normal_mode
	if index(g:atp_completion_active_modes, 'labels') != -1 
	    let l:completion_method='labels'
	    "DEBUG:
	    let b:comp_method='label'
	else
	    let b:comp_method='label fast return'
	    return ''
	endif
    "}}}3
    "{{{3 bibitems
    elseif l:pline =~ '\\\%(no\)\?cite' && !l:normal_mode
	if index(g:atp_completion_active_modes, 'bibitems') != -1
	    let l:completion_method='bibitems'
	    "DEBUG:
	    let b:comp_method='bibitems'
	    if l:begin =~ '}\s*$'
		return ''
	    endif 
	else
	    let b:comp_method='bibitems fast return'
	    return ''
	endif
    "}}}3
    "{{{3 tikzpicture
    elseif search('\%(\\def\>.*\|\\\%(re\)\?newcommand\>.*\|%.*\)\@<!\\begin{tikzpicture}','bnW') > search('[^%]*\\end{tikzpicture}','bnW') ||
	\ !atplib#CompareCoordinates(searchpos('[^%]*\zs\\tikz{','bnw'),searchpos('}','bnw'))
	"{{{4 tikzpicture keywords
	if l:l =~ '\%(\s\|\[\|{\|}\|,\|\.\|=\|:\)' . l:tbegin . '$' && l:normal_mode
	    if index(g:atp_completion_active_modes, 'tikzpicture keywords') != -1 
		"DEBUG:
		let b:comp_method='tikzpicture keywords'
		let l:completion_method="tikzpicture keywords"
	    else
		let b:comp_method='tikzpicture keywords fast return'
		return ''
	    endif
	"}}}4
	"{{{4 tikzpicture commands
	elseif  l:l =~ '\\' . l:tbegin  . '$' && !l:normal_mode
	    if index(g:atp_completion_active_modes, 'tikzpicture commands') != -1
		"DEBUG:
		let b:comp_method='tikzpicture commands'
		let l:completion_method="tikzpicture commands"
	    else
		let b:comp_method='tikzpicture commands fast return'
		return ''
	    endif
	"}}}4
	"{{{4 close_env tikzpicture
	else
	    if (!normal_mode &&  index(g:atp_completion_active_modes, 'close environments') != -1 ) ||
			\ (l:normal_mode && index(g:atp_completion_active_modes_normal_mode, 'close environments') != -1 )
		"DEBUG:
		let b:comp_method='close_env tikzpicture'
		let l:completion_method="close_env"
	    else
		let b:comp_method='close_env tikzpicture fast return'
		return ''
	    endif
	endif
    "}}}3
    "{{{3 package
    elseif l:pline =~ '\\usepackage\%([.*]\)\?\s*' && !l:normal_mode
	if index(g:atp_completion_active_modes, 'package names') != -1
	    let l:completion_method='package'
	    "DEBUG:
	    let b:comp_method='package'
	else
	    let b:comp_method='package fast return'
	    return ''
	endif
    "}}}3
    "{{{3 tikz libraries
    elseif l:pline =~ '\\usetikzlibrary\%([.*]\)\?\s*' && !l:normal_mode
	if index(g:atp_completion_active_modes, 'tikz libraries') != -1
	    let l:completion_method='tikz libraries'
	    "DEBUG:
	    let b:comp_method='tikz libraries'
	else
	    let b:comp_method='tikz libraries fast return'
	    return ''
	endif
    "}}}3
    "{{{3 inputfiles
    elseif ((l:pline =~ '\\input' || l:begin =~ 'input') ||
	  \ (l:pline =~ '\\include' || l:begin =~ 'include') ||
	  \ (l:pline =~ '\\includeonly' || l:begin =~ 'includeonly') ) && !l:normal_mode 
	if l:begin =~ 'input'
	    let l:begin=substitute(l:begin,'.*\%(input\|include\%(only\)\?\)\s\?','','')
	endif
	if index(g:atp_completion_active_modes, 'input files') != -1
	    let l:completion_method='inputfiles'
	    " DEBUG:
	    let b:comp_method='inputfiles'
	else
	    let b:comp_method='inputfiles fast return'
	    return ''
	endif
    "}}}3
    "{{{3 bibfiles
    elseif l:pline =~ '\\bibliography\%(style\)\@!' && !l:normal_mode
	if index(g:atp_completion_active_modes, 'bibitems') != -1
	    let l:completion_method='bibfiles'
	    " DEBUG:
	    let b:comp_method='bibfiles'
	else
	    let b:comp_method='bibfiles fast return'
	    return ''
	endif
    "}}}3
    "{{{3 bibstyles
    elseif l:pline =~ '\\bibliographystyle' && !l:normal_mode 
	if (index(g:atp_completion_active_modes, 'bibstyles') != -1 ) 
	    let l:completion_method='bibstyles'
	    let b:comp_method='bibstyles'
	else
	    let b:comp_method='bibstyles fast return'
	    return ''
	endif
    "}}}3
    "{{{3 documentclass
    elseif l:pline =~ '\\documentclass\>' && !l:normal_mode 
	if index(g:atp_completion_active_modes, 'documentclass') != -1
	    let l:completion_method='documentclass'
	    let b:comp_method='documentclass'
	else
	    let b:comp_method='documentclass fast return'
	    return ''
	endif
    "}}}3
    "{{{3 brackets
    " TODO: here should be check if opened closed with mode 0  (0,1,2)!!! this doesn't work in
    " some situations.
    elseif index(g:atp_completion_active_modes,'brackets') != -1 && 
		\ (searchpairpos('\\\@<!(','', '\\\@<!)', 'bnW', "", l:limit_line) != [0, 0] ||  
		\ searchpairpos('\%(\\begin\|\\end\)\@<!{',	  '', '}',	 'bnW', "", l:limit_line) 	!= [0, 0] || 
		\ searchpairpos('\\\@<!\[',	  '', '\\\@<!\]',	 'bnW', "", l:limit_line)	!= [0, 0] )
" 		\ searchpairpos('{',	  '', '}',	 'bnW', "", l:limit_line) 	!= [0, 0] || 
	if (!normal_mode &&  index(g:atp_completion_active_modes, 'brackets') != -1 ) ||
		    \ (l:normal_mode && index(g:atp_completion_active_modes_normal_mode, 'brackets') != -1 )
	    let b:comp_method='brackets'
	    call atplib#CloseLastBracket()
	    return '' 
	else
	    let b:comp_method='brackets fast return'
	    return ''
	endif
    "}}}3
    "{{{3 close environments
    else
	if (!normal_mode &&  index(g:atp_completion_active_modes, 'close environments') != '-1' ) ||
		    \ (l:normal_mode && index(g:atp_completion_active_modes_normal_mode, 'close environments') != '-1' )
	    let l:completion_method='close_env'
	    "DEBUG:
	    let b:comp_method='close_env a' 
	else
	    let b:comp_method='close_env a fast return' 
	    return ''
	endif
    endif
    " if the \[ is not closed we prefer to first close it and then to complete
    " the commands, it is better as then automatic tex will have better file
    " to operate on.
    " }}}3
" }}}2
" {{{2 close environments
    if l:completion_method=='close_env'
	let l:env_opened = atplib#CheckOpened(
		    \ '\%(%.*\)\@<!\\begin\s*{\%(document\)\@!',
		    \ '\%(%.*\)\@<!\\end\s*{\%(document\)\@!',
		    \ line('.'),g:atp_completion_limits[2],2)
    "     let l:env_opened = atplib#CheckOpened('\%(%.*\)\@<!\\begin\s*{\%(document\)\@!','\%(%.*\)\@<!\\end\s*{\%(document\)\@!',
    " 				\ line('.'),g:atp_completion_limits[2],2)
    "     let l:env_opened = min([atplib#CheckOpened('\%(%.*\)\@<!\\begin{\%(document\)\@!','\%(%.*\)\@<!\\end{\%(document\)\@!',
    " 				\ line('.'),g:atp_completion_limits[2],1),
    " 				\ atplib#CheckOpened('\%(%.*\)\@<!\\begin{\%(document\)\@!','\%(%.*\)\@<!\\end{\%(document\)\@!',
    " 				\ line('.'),g:atp_completion_limits[2],2)])
" 	let b:env_opened = l:env_opened
" 	if l:env_opened != 0
" 	    let l:env_lnr=l:env_opened
" 	    " this might be wrong env_name!! I should not use this.
" " 	    let l:env_name=matchstr(getline(l:env_lnr),'\\begin\s*{\zs[^}]*\ze}\%(.*\\begin\s*{\)\@!')
" " 	    let l:env_closed 	= atplib#CheckClosed('\%(%.*\)\@<!\\begin{' . l:env_name,'\%(%.*\)\@<!\\end{' . l:env_name,
" " 				    \ line('.'),g:atp_completion_limits[2],1)
" 	else
" 	    let l:env_name=0 	" this is compatible with atplib#CloseLastEnvironment() function (argument for a:3).
" 	endif
" 	let l:imath_closed	= atplib#CheckClosed(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line('.'),g:atp_completion_limits[0])
" 	let l:imath_opened	= atplib#CheckOpened(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line('.'),g:atp_completion_limits[0])
" 	let l:dmath_closed	= atplib#CheckClosed(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1])
" 	let l:dmath_opened	= atplib#CheckOpened(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1])
	let l:limit_imath=max([1,(line(".")-g:atp_completion_limits[0])])
	let l:limit_dmath=max([1,(line(".")-g:atp_completion_limits[1])])
	let l:imath_opened=searchpair(g:atp_math_modes[0][0],'',g:atp_math_modes[0][1],'bnW',"",l:limit_imath)
	let l:dmath_opened=searchpair(g:atp_math_modes[1][0],'',g:atp_math_modes[1][1],'bnW',"",l:limit_dmath)
    " DEBUG:
"     echomsg "ic " l:imath_closed 		. " io " . l:imath_opened . 
" 		\ " dc " . l:dmath_closed 	. " do " . l:dmath_opened . 
" 		\ " ec " . l:env_closed 	. " eo " . l:env_opened
    let b:imath_opened=l:imath_opened
"     let b:imath_closed=l:imath_closed
    let b:dmath_opened=l:dmath_opened
"     let b:dmath_closed=l:dmath_closed
"     let b:env_closed = l:env_closed " DEBUG
    let b:env_opened = l:env_opened " DEBUG
"     let b:env_name=l:env_name
    let b:env_lnr=l:env_opened

	if l:env_opened || l:imath_opened || l:dmath_opened
	    if l:imath_opened 
		call atplib#CloseLastEnvironment(b:append,'inline_math')
		let b:tc_return="close_env inl"
		return ''
	    elseif l:dmath_opened
		call atplib#CloseLastEnvironment(b:append,'displayed_math')
		let b:tc_return="close_env disp"
		return ''
	    " THIS IS COOL:
	    " it is better than CheckOpened and CheckClosed and probably
	    " faster.
	    elseif searchpair('\\begin','','\\end','bnW','searchpair("\\\\begin{".matchstr(getline("."),"\\\\begin{\\zs[^}]*\\ze}"),"","\\\\end{".matchstr(getline("."),"\\\\begin{\\zs[^}]*\\ze}"),"nW")',max([1,(line(".")-g:atp_completion_limits[2])]))
" 	    elseif !l:env_closed && l:env_opened	
"		this doesn't work because atplib#CheckOpened is not
"		returning the right line. (Should return the nearest opened
"		env.

"		ToDo: calling atplib#CloseLastEnvironment() below cost 0.17s which is 43% of the
"		total time (0.4s). This can be saved if the above work well.
"		Can atplib#CloseLastEnv make less checks and work faster?

		" the env name above might be not the one because it is looked
		" using '\\begin' and '\\end' this might be not enough,
		" however the function atplib#CloseLastEnv works prefectly and this
		" should be save:
		call atplib#CloseLastEnvironment(b:append,'environment')
		let b:tc_return="close_env opened:" . l:env_opened 
		return ''
	    endif
	endif

	return ''
    endif
" }}}2
" {{{2 SET COMPLETION LIST
    " generate the completion names
    " {{{3 ------------ ENVIRONMENT NAMES
    if l:completion_method == 'environment_names'
	let l:end=strpart(l:line,l:pos[2]-1)
	if l:end !~ '\s*}'
	    let l:completion_list=deepcopy(g:atp_environments)
	    if g:atp_local_completion
		" Make a list of local envs and commands
		if !exists("s:atp_local_environments") 
		    if exists("b:atp_local_environments")
			let s:atp_local_environments=b:atp_local_environments
		    elseif exists("g:atp_local_environments")
			let s:atp_local_environments=g:atp_local_environments
		    else
			let s:atp_local_environments=LocalCommands()[1]
		    endif
		endif
		let l:completion_list=atplib#Extend(l:completion_list,s:atp_local_environments)
	    endif
	    let l:completion_list=atplib#Add(l:completion_list,'}')
	else
	    let l:completion_list=deepcopy(g:atp_environments)
	    if g:atp_local_completion
		" Make a list of local envs and commands
		if !exists("s:atp_local_environments") 
		    if exists("b:atp_local_environments")
			let s:atp_local_environments=b:atp_local_environments
		    elseif exists("g:atp_local_environments")
			let s:atp_local_environments=g:atp_local_environments
		    else
			let s:atp_local_environments=LocalCommands()[1]
		    endif
		endif
		call atplib#Extend(l:completion_list,s:atp_local_environments)
	    endif
	endif
	" TIKZ
	keepjumps call setpos(".",[0,1,1,0])
	let l:stop_line=search('\\begin\s*{document}','cnW')
	keepjumps call setpos(".",l:pos_saved)
	if atplib#SearchPackage('tikz',l:stop_line) && 
		    \ ( !g:atp_check_if_opened || 
		    \ atplib#CheckOpened('\\begin\s*{tikzpicture}','\\end\s*{tikzpicture}',line('.'),80) || 
		    \ atplib#CheckOpened('\\tikz{','}',line("."),g:atp_completion_limits[2]) )
	    if l:end !~ '\s*}'
		call extend(l:completion_list,atplib#Add(g:atp_tikz_environments,'}'))
	    else
		call extend(l:completion_list,g:atp_tikz_environments)
	    endif
	endif
	" AMSMATH
	if atplib#SearchPackage('amsmath',l:stop_line) || g:atp_amsmath == 1 || atplib#DocumentClass() =~ '^ams'
	    if l:end !~ '\s*}'
		call extend(l:completion_list,atplib#Add(g:atp_amsmath_environments,'}'),0)
	    else
		call extend(l:completion_list,g:atp_amsmath_environments,0)
	    endif
	endif
    " }}}3
    "{{{3 ------------ PACKAGE
    elseif l:completion_method == 'package'
" 	let l:completion_list=deepcopy(g:atp_package_list)    
	let l:completion_list=atplib#FindFiles("tex","sty")
    "}}}3
    " {{{3 ------------ TIKZ LIBRARIES
    elseif l:completion_method == 'tikz libraries'
	let l:completion_list=deepcopy(g:atp_tikz_libraries)
    " }}}3
    " {{{3 ------------ TIKZPICTURE KEYWORD
    elseif l:completion_method == 'tikzpicture keywords'
	keepjumps call setpos(".",[0,1,1,0])
	let l:stop_line=search('\\begin\s*{document}','cnW')
	keepjumps call setpos(".",l:pos_saved)

	let l:completion_list=deepcopy(g:atp_tikz_keywords)
	" ToDo: it can be faster to find once which libraries are defined and then
	" check them.
	if atplib#SearchPackage('.*arrows',l:stop_line,'usetikzlibrary')
	    call extend(l:completion_list,g:atp_tikz_library_arrows_keywords)
	endif   
	if atplib#SearchPackage('.*automata',l:stop_line,'usetikzlibrary')
	    call extend(l:completion_list,g:atp_tikz_library_automata_keywords)
	endif   
	if atplib#SearchPackage('.*background',l:stop_line,'usetikzlibrary')
	    call extend(l:completion_list,g:atp_tikz_library_backgrounds_keywords)
	endif   
	if atplib#SearchPackage('.*calendar',l:stop_line,'usetikzlibrary')
	    call extend(l:completion_list,g:atp_tikz_library_calendar_keywords)
	endif
	if atplib#SearchPackage('.*chain',l:stop_line,'usetikzlibrary')
	    call extend(l:completion_list,g:atp_tikz_library_chain_keywords)
	endif
	if atplib#SearchPackage('.*decorations',l:stop_line,'usetikzlibrary')
	    call extend(l:completion_list,g:atp_tikz_library_decoration_keywords)
	endif
	if atplib#SearchPackage('.*matrix',l:stop_line,'usetikzlibrary')
	    call extend(l:completion_list,g:atp_tikz_library_matrix_keywords)
	endif   
    " }}}3
    " {{{3 ------------ TIKZPICTURE COMMAND
"     elseif l:completion_method == 'tikzpicture commands'
" 	let l:tbegin=strpart(l:l,l:o+1)
" 	let l:completion_list = deepcopy(g:atp_tikz_commands)
" 	" ToDo: Should it add more math commands?
" 	call extend(l:completion_list,g:atp_math_commands)
    " }}}3
    " {{{3 ------------ COMMAND
    elseif l:completion_method == 'command'
	let l:tbegin=strpart(l:l,l:o+1)
	let l:completion_list=[]
	 
	" Are we in the math mode?
	let l:math_is_opened=0
	if g:atp_math_opened
	    for l:key in g:atp_math_modes
" 		if atplib#CheckOpened(l:key[0],l:key[1],line("."),g:atp_completion_limits[2],0)
		if searchpair(l:key[0],'',l:key[1],'bnWc')
		    let l:math_is_opened=1
		    break
		endif
	    endfor
	endif
" 	let b:math_is_opened=l:math_is_opened

	if searchpair('\\begin{picture}','','\\end{picture}','bnW')
	    call extend(l:completion_list,g:atp_picture_commands)
	endif

	" Find end of the preambule
	keepjumps call setpos(".",[0,1,1,0])
	let l:stop_line=search('\\begin\s*{document}','cnW')
	keepjumps call setpos(".",l:pos_saved)

	" {{{4 math commands 
	" if we are in math mode or if we do not check for it.
	if g:atp_no_math_command_completion != 1 &&  ( !g:atp_math_opened || l:math_is_opened )
	    call extend(l:completion_list,g:atp_math_commands)
	    " amsmath && amssymb {{{5
	    if g:atp_amsmath == 1 || atplib#DocumentClass() =~ '^ams'  
		call extend(l:completion_list,g:atp_amsmath_commands,0)
		call extend(l:completion_list,g:atp_ams_negations)
		if a:expert_mode == 0 
		    call extend(l:completion_list,g:atp_ams_negations_non_expert_mode)
		endif
	    else
		if atplib#SearchPackage('amsmath',l:stop_line)
		    call extend(l:completion_list,g:atp_amsmath_commands,0)
		endif
		if atplib#SearchPackage('amssymb',l:stop_line)
		    call extend(l:completion_list,g:atp_ams_negations)
		    if a:expert_mode == 0 
			call extend(l:completion_list,g:atp_ams_negations_non_expert_mode)
		    endif
		endif
	    endif " }}}5
	    " math non expert mode {{{5
	    if a:expert_mode == 0
		call extend(l:completion_list,g:atp_math_commands_non_expert_mode)
	    endif "}}}5
	endif
	" }}}4
	" TIKZ {{{4
	" if tikz is declared and we are in tikz environment.
	if atplib#SearchPackage('tikz',l:stop_line)
	    if search('\\begin{tikzpicture}','bnW') > search('\\end{tikzpicture}','bnW') ||
			\ !atplib#CompareCoordinates(searchpos('\\tikz{','bnW'),searchpos('}','bnW'))
		call extend(l:completion_list,g:atp_tikz_commands)
		if atplib#SearchPackage('.*calendar',l:stop_line,'usetikzlibrary')
		    call extend(l:completion_list,g:atp_tikz_library_calendar)
		endif
		if atplib#SearchPackage('.*chain','usetikzlibrary')
		    call extend(l:completion_list,g:atp_tikz_library_chain)
		endif
	    endif
	endif
	"}}}4
	" LOCAL COMMNADS {{{4
	if g:atp_local_completion
	    " Make a list of local envs and commands
	    if !exists("s:atp_local_commands") 
		if exists("b:atp_local_commands")
		    let s:atp_local_commands=g:atp_local_commands
		elseif exists("g:atp_local_commands")
		    let s:atp_local_commands=b:atp_local_commands
		else
		    let s:atp_local_commands=LocalCommands()[1]
		endif
	    endif
	    call extend(l:completion_list,s:atp_local_commands)
	endif
	"}}}4
	" {{{4 Non math commands
" 	let b:deb=g:atp_math_opened ." ". l:math_is_opened ." ". a:expert_mode
"	if we are not in math mode or if we do not care about it or we are in non expert mode.
	if (!g:atp_math_opened || !l:math_is_opened ) || a:expert_mode == 0
	    call extend(l:completion_list,g:atp_commands)
	    " NICEFRAC
	    if atplib#SearchPackage('nicefrac',l:stop_line)
		call add(l:completion_list,"\\nicefrac{")
	    endif
	    " FANCYHDR
	    if atplib#SearchPackage('fancyhdr',l:stop_line)
		call extend(l:completion_list,g:atp_fancyhdr_commands)
	    endif
	endif
	"}}}4
	" ToDo: add layout commands and many more packages. (COMMANDS FOR
	" PREAMBULE)
	"{{{4
	let l:env_name=substitute(l:pline,'.*\%(\\\%(begin\|end.*\){\(.\{-}\)}.*\|\\\%(\(item\)\s*\)\%(\[.*\]\)\?\s*$\)','\1\2','') 
	if l:env_name =~ '\\\%(\%(sub\)\?paragraph\|\%(sub\)*section\|chapter\|part\)'
	    let l:env_name=substitute(l:env_name,'.*\\\(\%(sub\)\?paragraph\|\%(sub\)*section\|chapter\|part\).*','\1','')
	endif
	let l:env_name=substitute(l:env_name,'\*$','','')
	" if the pattern did not work do not put the env name.
	" for example \item cos\lab<Tab> the pattern will not work and we do
	" not want env name. 
	if l:env_name == l:pline
	    let l:env_name=''
	endif
" 	let b:env_name=l:env_name " DEBUG

	if has_key(g:atp_shortname_dict,l:env_name)
	    if g:atp_shortname_dict[l:env_name] != 'no_short_name' && g:atp_shortname_dict[l:env_name] != '' 
		let l:short_env_name=g:atp_shortname_dict[l:env_name]
		let l:no_separator=0
	    else
		let l:short_env_name=''
		let l:no_separator=1
	    endif
	else
	    let l:short_env_name=''
	    let l:no_separator=1
	endif

" 	if index(g:atp_no_separator_list,l:env_name) != -1
" 	    let l:no_separator = 1
" 	endif

	if g:atp_env_short_names == 1
	    if l:no_separator == 0 && g:atp_no_separator == 0
		let l:short_env_name=l:short_env_name . g:atp_separator
	    endif
	else
	    let l:short_env_name=''
	endif

	call extend(l:completion_list, [ '\label{' . l:short_env_name ],0)
	"}}}4

    " }}}3
    " {{{3 ------------ LABELS
    elseif l:completion_method == 'labels'
	let l:completion_list=[]
	let l:completion_list=deepcopy(values(atplib#generatelabels(fnamemodify(bufname("%"),":p"))[fnamemodify(bufname("%"),":p")]))
	if l:nchar != '}'
	    call map(l:completion_list,'v:val."}"')
	endif
    " }}}3
    " {{{3 ------------ TEX INPUTFILES
    elseif l:completion_method ==  'inputfiles'
	let l:inputfiles=atplib#FindInputFiles(g:texmf,1,".tex")
	let l:completion_list=[]
	for l:key in l:inputfiles
	    call add(l:completion_list,fnamemodify(l:key,":t:r"))
	endfor
	call sort(l:completion_list)
    " }}}3
    " {{{3 ------------ BIBFILES
    elseif l:completion_method ==  'bibfiles'
	let l:bibfiles=[]
	for l:dir in g:atp_bibinputs
	    let l:bibfiles=extend(l:bibfiles,atplib#FindInputFiles(l:dir,0,".bib"))
	endfor
	let l:completion_list=[]
	for l:key in l:bibfiles
	    call add(l:completion_list,fnamemodify(l:key,":t:r"))
	endfor
	call sort(l:completion_list)
    " }}}3
    " {{{3 ------------ BIBSTYLES
    elseif l:completion_method == 'bibstyles'
	let l:completion_list=atplib#FindFiles("bst","bst")
    "}}}3
    "{{{3 ------------ DOCUMENTCLASS
    elseif l:completion_method == 'documentclass'
	let l:completion_list=atplib#FindFiles("tex","cls")
	if l:nchar != "}"
	    call map(l:completion_list,'v:val."}"')
	endif
    " }}}3
    " {{{3 ------------ BIBITEMS
    elseif l:completion_method == 'bibitems'
	let l:col = col('.') - 1
	while l:col > 0 && line[l:col - 1] !~ '{\|,'
		let l:col -= 1
	endwhile
	let l:pat=strpart(l:l,l:col)
	let b:pat=l:pat
	let l:bibitems_list=values(atplib#searchbib(l:pat))
" 	let b:bibitmes_list=l:bibitems_list " DEBUG
	let l:pre_completion_list=[]
	let l:completion_dict=[]
" 	let b:completion_dict=l:completion_dict " DEBUG
	let l:completion_list=[]
	for l:dict in l:bibitems_list
	    for l:key in keys(l:dict)
		" ToDo: change l:dict[l:key][...] to get() to not get errors
		" if it is not present or to handle situations when it is not
		" present!
		call add(l:pre_completion_list, l:dict[l:key]['bibfield_key']) 
		let l:bibkey=l:dict[l:key]['bibfield_key']
		let l:bibkey=substitute(strpart(l:bibkey,max([stridx(l:bibkey,'{'),stridx(l:bibkey,'(')])+1),',\s*','','')
		if l:nchar != ',\|}'
		    let l:bibkey.="}"
		endif
		let l:title=get(l:dict[l:key],'title','notitle')
" 		if l:title == 'notitle'
" 		    let l:title=get(l:dict[l:key],'booktitle','')
" 		endif
		let l:title=substitute(matchstr(l:title,'^\s*title\s*=\s*\%("\|{\|(\)\zs.*\ze\%("\|}\|)\)\s*\%(,\|$\)'),'{\|}','','g')
		let l:year=get(l:dict[l:key],'year',"")
		let l:year=matchstr(l:year,'^\s*year\s*=\s*\%("\|{\|(\)\zs.*\ze\%("\|}\|)\)\s*\%(,\|$\)')
		let l:abbr=get(l:dict[l:key],'author',"noauthor")
		let l:author = matchstr(l:abbr,'^\s*author\s*=\s*\%("\|{\|(\)\zs.*\ze\%("\|}\|)\)\s*,')
		if l:abbr=="noauthor" || l:abbr == ""
		    let l:abbr=get(l:dict[l:key],'editor',"")
		    let l:author = matchstr(l:abbr,'^\s*editor\s*=\s*\%("\|{\|(\)\zs.*\ze\%("\|}\|)\)\s*,')
		endif
		if len(l:author) >= 40
		    if match(l:author,'\sand\s')
			let l:author=strpart(l:author,0,match(l:author,'\sand\s')) . ' et al.'
		    else
			let l:author=strpart(l:author,0,40)
		    endif
		endif
		let l:author=substitute(l:author,'{\|}','','g')
		if l:dict[l:key]['bibfield_key'] =~ 'article'
		    let l:type="[a]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'book\>'
		    let l:type="[B]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'booklet'
		    let l:type="[b]"
		elseif  l:dict[l:key]['bibfield_key'] =~ 'proceedings\|conference'
		    let l:type="[p]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'unpublished'
		    let l:type="[u]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'incollection'
		    let l:type="[c]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'phdthesis'
		    let l:type="[PhD]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'masterthesis'
		    let l:type="[M]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'misc'
		    let l:type="[-]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'techreport'
		    let l:type="[t]"
		elseif l:dict[l:key]['bibfield_key'] =~ 'manual'
		    let l:type="[m]"
		else
		    let l:type="   "
		endif

		let l:abbr=l:type." ".l:author." (".l:year.") "

		call add(l:completion_dict, { "word" : l:bibkey, "menu" : l:title, "abbr" : l:abbr }) 
	    endfor
	endfor
	for l:key in l:pre_completion_list
	    call add(l:completion_list,substitute(strpart(l:key,max([stridx(l:key,'{'),stridx(l:key,'(')])+1),',\s*','',''))
	endfor

	" add the \bibitems found in include files
	call extend(l:completion_list,keys(atplib#SearchBibItems(b:atp_mainfile)))
    endif
    " }}}3
    if exists("l:completion_list")
	let b:completion_list=l:completion_list	" DEBUG
    endif
    " }}}2
" {{{2 make the list of matching completions
    "{{{3 if l:completion_method != close environments && != env_close
    if l:completion_method != 'close environments' && l:completion_method != 'env_close'
	let l:completions=[]
	    " Packages, environments, labels, bib and input files must match
	    " at the beginning (in expert_mode).
	    if (l:completion_method == 'package' ||
			\ l:completion_method == 'environment_names' ||
			\ l:completion_method == 'labels' ||
			\ l:completion_method == 'bibfiles' ||
			\ l:completion_method == 'bibstyles' ||
			\ l:completion_method == 'documentclass' )
		if a:expert_mode == 1
		    let l:completions=filter(deepcopy(l:completion_list),' v:val =~ "\\C^".l:begin') 
		elseif a:expert_mode!=1
		    let l:completions=filter(deepcopy(l:completion_list),' v:val =~ l:begin') 
		endif
	    " Bibitems match not only in the beginning!!! 
	    elseif (l:completion_method == 'tikz libraries' ||
			\ l:completion_method == 'inputfiles')
		let l:completions=filter(deepcopy(l:completion_list),' v:val =~ l:begin') 
		if l:nchar != "}" && l:nchar != "," && l:completion_method != 'inputfiles'
		    call map(l:completions,'v:val."}"')
		endif
	    " Commands must match at the beginning (but in a different way)
	    " (only in epert_mode).
	    " ToDo: make this faster using map or filter command!
" 	    elseif l:completion_method == 'bibitems'
" 		let l:completions=l:completion_list
	    elseif l:completion_method == 'command' 
" 		for l:item in l:completion_list
" 		    if l:nchar == '}'
			if a:expert_mode == 1 
" 			    && l:item =~ '\C^\\' . l:tbegin && l:item =~ '.*{[}\s]*$'
			    let l:completions=filter(copy(l:completion_list),'v:val =~ "\\C^\\\\".l:tbegin')
" 			    call add(l:completions, substitute(l:item,'{[}\s]*$','',''))
			elseif a:expert_mode != 1 
" 			    && l:item =~  l:tbegin && l:item =~ '.*{[}\s]*$'
			    let l:completions=filter(copy(l:completion_list),'v:val =~ l:tbegin')
" 			    call add(l:completions, '\' . substitute(l:item,'{[}\s]*$','',''))
			endif
" 		    else
" 			if a:expert_mode == 1  && l:item =~ '\C^\\' . l:tbegin
" 			    call add(l:completions,l:item)
" 			elseif a:expert_mode != 1  && l:item =~  l:tbegin
" 			    let l:completions=filter(l:completion_list,'v:val =~ l:tbegin')
" 			    call add(l:completions,l:item)
" 			endif
" 		    endif
" 		endfor
	    elseif l:completion_method == 'tikzpicture keywords'
		if a:expert_mode == 1 
		    let l:completions=filter(deepcopy(l:completion_list),'v:val =~ "\\C^".l:tbegin') 
		elseif a:expert_mode != 1 
		    let l:completions=filter(deepcopy(l:completion_list),'v:val =~ l:tbegin') 
		endif
	    elseif l:completion_method == 'tikzpicture commands'
		if a:expert_mode == 1 
		    let l:completions=filter(deepcopy(l:completion_list),'v:val =~ "\\C^".l:tbegin') 
		elseif a:expert_mode != 1 
		    let l:completions=filter(deepcopy(l:completion_list),'v:val =~ l:tbegin') 
		endif
	    endif
    "}}}3
    "{{{3 else: try to close environment
    else
	call atplib#CloseLastEnvironment('a','environment')
	let b:tc_return="1"
	return ''
    endif
    let b:completions=l:completions " DEBUG
    if g:atp_completion_truncate && a:expert_mode
	call filter(l:completions,'len(substitute(v:val,"^\\","","")) >= g:atp_completion_truncate')
    endif
    " if the list is long it is better if it is sorted, if it short it is
    " better if the more used things are at the begining.
    if len(l:completions) > 5 && l:completion_method != 'labels'
	let l:completions=sort(l:completions)
    endif
    " }}}2
    " complete {{{2
    if l:completion_method == 'labels' 			|| 
		\ l:completion_method == 'package' 	|| 
		\ l:completion_method == 'tikz libraries'    || 
		\ l:completion_method == 'environment_names' ||
		\ l:completion_method == 'bibfiles' 	|| 
		\ l:completion_method == 'bibstyles' 	|| 
		\ l:completion_method == 'documentclass'|| 
		\ l:completion_method == 'inputfiles' 
	call complete(l:nr+2,l:completions)
	let b:tc_return="labels,package,tikz libraries,environment_names,bibitems,bibfiles,inputfiles"
    elseif !l:normal_mode && l:completion_method == 'bibitems'
	call complete(l:col+1,l:completion_dict)
    elseif !l:normal_mode && (l:completion_method == 'command' || l:completion_method == 'tikzpicture commands')
	call complete(l:o+1,l:completions)
	let b:tc_return="command X"
    elseif !l:normal_mode && (l:completion_method == 'tikzpicture keywords')
	let l:t=match(l:l,'\zs\<\w*$')
" 	let b:t=l:t
	" in case '\zs\<\w*$ is empty
	if l:t == -1
	    let l:t=col(".")
	endif
	call complete(l:t+1,l:completions)
	let b:tc_return="tikzpicture keywords"
    endif
    " If the completion method was a command (probably in a math mode) and
    " there was no completion, check if environments are closed.
    " {{{ 3 Final call of CloseLastEnvrionment / CloseLastBracket
    let l:len=len(l:completions)
    if l:len <= 1
	if (l:completion_method == 'command' || l:completion_method == 'tikzpicture commands') && 
	    \ (l:len == 0 && a:expert_mode ||
	    \  l:len == 1 && l:completions[0] == '\'. l:begin ) &&
	    \  !atplib#CheckClosed(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line("."),g:atp_completion_limits[0])
	    " DEBUG:
    " 	let b:dmc=atplib#CheckClosed(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1])
    " 	let b:dmo=atplib#CheckOpened(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1])

" 	    if !atplib#CheckClosed(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1]) && atplib#CheckOpened(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1])
" 		call atplib#CloseLastEnvironment('i','displayed_math')
" 	    elseif !atplib#CheckClosed(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line('.'),g:atp_completion_limits[0]) && atplib#CheckOpened(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line('.'),g:atp_completion_limits[1])
" 		call atplib#CloseLastEnvironment('i','inline_math')
" 	    elseif !atplib#CheckClosed('\\begin\s*{','\\end\*{',line("."),g:atp_completion_limits[2]) &&
" 			\ atplib#CheckOpened('\\begin\s*{','\\end\*{',line("."),g:atp_completion_limits[2])
" 		call atplib#CloseLastEnvironment('a','environment')
" 	    endif

" let b:inline=atplib#CheckOpened(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line('.'),g:atp_completion_limits[0],1) . " " . !searchpair(escape(g:atp_math_modes[0][0],'\'),'',escape(g:atp_math_modes[0][1],'\'),'bnW')
" let b:disp=atplib#CheckOpened(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1],1) . " " . !searchpair(escape(g:atp_math_modes[1][0],'\'),'',escape(g:atp_math_modes[1][1],'\'),'bnW')
" let b:env=atplib#CheckOpened('\\begin\s*{','\\end\*{',line("."),g:atp_completion_limits[2],1) ." ".!searchpair('\\begin\s*{','','\\end\s*{\zs','bnW')

" TODO: add check that the last opened env is closed (when \(:\) and \[:\] are in
" the same line there is a problem!!!!!! 
	let l:imath_opened=searchpair(g:atp_math_modes[0][0],'',g:atp_math_modes[0][1],'bnW')
	let l:dmath_opened=searchpair(g:atp_math_modes[1][0],'',g:atp_math_modes[1][1],'bnW')
	if atplib#CheckOpened(g:atp_math_modes[0][0],g:atp_math_modes[0][1],line('.'),g:atp_completion_limits[0],1) && !searchpair(escape(g:atp_math_modes[0][0],'\'),'',escape(g:atp_math_modes[0][1],'\'),'bnW')
	    call atplib#CloseLastEnvironment('i','inline_math')
	    let l:a="inline math"
	elseif atplib#CheckOpened(g:atp_math_modes[1][0],g:atp_math_modes[1][1],line('.'),g:atp_completion_limits[1],1) && !searchpair(escape(g:atp_math_modes[1][0],'\'),'',escape(g:atp_math_modes[1][1],'\'),'bnW')
	    call atplib#CloseLastEnvironment('i','displayed_math')
	    let l:a="displayed math"
	" THIS IS COOL:
	elseif searchpair('\\begin','','\\end','bnW','searchpair("\\\\begin{".matchstr(getline("."),"\\\\begin{\\zs[^}]*\\ze}"),"","\\\\end{".matchstr(getline("."),"\\\\begin{\\zs[^}]*\\ze}"),"nW")',max([1,(line(".")-g:atp_completion_limits[2])]))
	    call atplib#CloseLastEnvironment('a','environment')
	endif
	let b:comp_method.=' close_env end' "DEBUG
    	if exists("l:a")
    	    let b:tc_return.=" close_env end " . l:a
    	else
    	    let b:tc_return.=" close_env end"
    	endif
	elseif l:completion_method == 'package' || 
		    \  l:completion_method == 'bibstyles' || 
		    \ l:completion_method == 'bibfiles' ||
		    \ l:completion_method == 'bibitems'
	    " this is already done:
" 		    \ l:completion_method == 'tikz libraries'
" 		    \ l:completion_method == 'labels'
	    let b:tc_return='close_bracket end'
	    call atplib#CloseLastBracket()
	endif
    endif
    "}}}3

"  ToDo: (a chalanging one)  
"  Move one step after completion is done (see the condition).
"  for this one have to end till complete() function will end, and this I do
"  not know how to do. 
"     let b:check=0
"     if l:completion_method == 'environment_names' && l:end =~ '\s*}'
" 	let b:check=1
" 	let l:pos=getpos(".")
" 	let l:pos[2]+=1
" 	call setpos(".",l:pos) 
"     endif
"
    " unlet variables if there were defined.
    if exists("l:completion_list")
	unlet l:completion_list
    endif
    if exists("l:completions")
	unlet l:completions
    endif
    return ''
    "}}}2
endfunction
" }}}1

"{{{1 atplib#FontSearch
" These functions search for fd files and show them in a buffer with filetype
" 'fd_atp'. There are additional function for this filetype written in
" fd_atp.vim ftplugin. Distributed with atp.

"{{{2 FontSearch
" atplib#FontSearch([<pattern>,<method>]) 
" method = 0 match for name of fd file
" method = 1 match againts whole path
if !exists("*atplib#FontSearch")
function! atplib#FontSearch(...)
	
    if a:0 == 0
	let l:pattern=""
	let l:method=0
    else
	let l:pattern=a:1
	if a:0 == 1
	    let l:method=0
	else
	    let l:method=1
	endif
    endif
"     let b:a=a:0
"     let b:method=l:method

    " Find fd file
    let l:path=substitute(substitute(system("kpsewhich -show-path tex"),'!!','','g'),'\/\/\+','\/','g')
    let l:path=substitute(l:path,':\|\n',',','g')
    let l:fd=split(globpath(l:path,"**/*.fd"),'\n') 

    " Match for l:pattern
    let s:fd_matches=[]
    for l:fd_file in l:fd
	if (l:method==0 && fnamemodify(l:fd_file,":t") =~ l:pattern) ||
		    \ (l:method==1 && l:fd_file =~ l:pattern)
	    call add(s:fd_matches,l:fd_file)
	endif
    endfor

    " Open Buffer and list fd files
    " set filetype to fd_atp
    let l:tmp_dir=tempname()
    call mkdir(l:tmp_dir)
    let l:fd_bufname="fd_list " . l:pattern
    let l:openbuffer="32vsplit! +setl\\ nospell\\ ft=fd_atp ". fnameescape(l:tmp_dir . "/" . l:fd_bufname )

    let g:fd_matches=[]
    if len(s:fd_matches) > 0
	echohl WarningMsg
	echomsg "Found " . len(s:fd_matches) . " files."
	echohl None
	" wipe out the old buffer and open new one instead
	if buflisted(fnameescape(l:tmp_dir . "/" . l:fd_bufname))
" 	    echomsg "DEBUG DELETE BUFFER"
	    silent exe "bd! " . bufnr(fnameescape(l:tmp_dir . "/" . l:fd_bufname))
	endif
	silent exe l:openbuffer
	" make l:tmp_dir available for this buffer.
" 	let b:tmp_dir=l:tmp_dir
	cd /tmp
	map <buffer> q	:bd<CR>

	" print the lines into the buffer
	let l:i=0
	call setline(1,"Press Enter to open a font definition file:")
	for l:fd_file in s:fd_matches
	    " we put in line the last directory/fd_filename:
	    " this is what we cut:
	    let l:path=fnamemodify(l:fd_file,":h:h")
	    let l:fd_name=substitute(l:fd_file,"^" . l:path . '/\?','','')
" 	    call setline(line('$')+1,fnamemodify(l:fd_file,":t"))
	    call setline(line('$')+1,l:fd_name)
	    call add(g:fd_matches,l:fd_file)
	    let l:i+=1
	endfor
	silent w
	setlocal nomodifiable
	setlocal ro
    else
	echohl WarningMsg
	echomsg "No fd file found."
	echohl None
    endif

endfunction
endif
"}}}2
"{{{2 Fd_completion /not needed/
" if !exists("*atplib#Fd_completion")
" function! atplib#Fd_completion(A,C,P)
"     	
"     " Find all files
"     let l:path=substitute(substitute(system("kpsewhich -show-path tex"),'!!','','g'),'\/\/\+','\/','g')
"     let l:path=substitute(l:path,':\|\n',',','g')
"     let l:fd=split(globpath(l:path,"**/*.fd"),'\n') 
"     let l:fd=map(l:fd,'fnamemodify(v:val,":t:r")')
" 
"     let l:matches=[]
"     for l:fd_file in l:fd
" 	if l:fd_file =~ a:A
" 	    call add(l:matches,l:fd_file)
" 	endif
"     endfor
"     return l:matches
" endfunction
" endif
" }}}2
" {{{2 OpenFdFile /not working && not needed?/
" function! atplib#OpenFdFile(name)
"     let l:path=substitute(substitute(system("kpsewhich -show-path tex"),'!!','','g'),'\/\/\+','\/','g')
"     let l:path=substitute(l:path,':\|\n',',','g')
"     let b:path=l:path
"     let l:fd=split(globpath(l:path,"**/".a:name.".fd"),'\n') 
"     let l:fd=map(l:fd,'fnamemodify(v:val,":t:r")')
"     let b:fd=l:fd
"     execute "split +setl\\ ft=fd_atp " . l:fd[0]
" endfunction
" }}}2
"{{{2 Preview
" keep_tex=1 open the tex file of the sample file, otherwise it is deleted (at
" least from the bufer list).
" To Do: fd_file could be a list of fd_files which we would like to see, every
" font should be done after \pagebreak[4]
function! atplib#Preview(fd_file,keep_tex)
    if a:fd_file != "buffer" 
	let l:fd_file=readfile(a:fd_file)
    else
	let l:fd_file=getline(1,"$")
    endif
    let l:declare_command='\C\%(DeclareFontShape\%(WithSizes\)\?\|sauter@\%(tt\)\?family\|EC@\%(tt\)\?family\|krntstexmplfamily\|HFO@\%(tt\)\?family\)'
    let b:declare_command=l:declare_command
    
    let l:font_decl=[]
    let b:font_decl=l:font_decl
    for l:line in l:fd_file
	if l:line =~ '\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}'
	    call add(l:font_decl,l:line)
	endif
    endfor

"     let l:tmp_dir=tempname()
    if exists("b:tmp_dir")
	let b:debug="tmp_dir from b:tmp_dir"
	let l:tmp_dir=b:tmp_dir
    else
	let b:debug="tmp_dir from tempname()"
	let l:tmp_dir=tempname()
    endif
    if !isdirectory(l:tmp_dir)
	call mkdir(l:tmp_dir)
    endif
    if a:fd_file == "buffer"
	let l:testfont_file=l:tmp_dir . "/" . fnamemodify(bufname("%"),":t:r") . ".tex"
    else
	let l:testfont_file=l:tmp_dir . "/" . fnamemodify(a:fd_file,":t:r") . ".tex"
    endif
    call system("touch " . l:testfont_file)
    
    let l:fd_bufnr=bufnr("%")

    let s:text="On November 14, 1885, Senator \\& Mrs.~Leland Stanford called
		\ together at their San Francisco mansion the 24~prominent men who had
		\ been chosen as the first trustees of The Leland Stanford Junior University.
		\ They handed to the board the Founding Grant of the University, which they
		\ had executed three days before.\\\\
		\ (!`THE DAZED BROWN FOX QUICLY GAVE 12345--67890 JUMPS!)"

"     let l:text="On November 14, 1885, Senator \\& Mrs.~Leland Stanford called
" 	\ together at their San Francisco mansion the 24~prominent men who had
" 	\ been chosen as the first trustees of The Leland Stanford Junior University.
" 	\ They handed to the board the Founding Grant of the University, which they
" 	\ had executed three days before. This document---with various amendments,
" 	\ legislative acts, and court decrees---remains as the University's charter.
" 	\ In bold, sweeping language it stipulates that the objectives of the University
" 	\ are ``to qualify students for personal success and direct usefulness in life;
" 	\ and to promote the publick welfare by exercising an influence in behalf of
" 	\ humanity and civilization, teaching the blessings of liberty regulated by
" 	\ law, and inculcating love and reverence for the great principles of
" 	\ government as derived from the inalienable rights of man to life, liberty,
" 	\ and the pursuit of happiness.''\\
" 	\ (!`THE DAZED BROWN FOX QUICKLY GAVE 12345--67890 JUMPS!)\\par}}
" 	\ \\def\\\moretext{?`But aren't Kafka's Schlo{\\ss} and {\\AE}sop's {\\OE}uvres
" 	\ often na{\\"\\i}ve  vis-\\`a-vis the d{\\ae}monic ph{\\oe}nix's official r\\^ole
" 	\ in fluffy souffl\\'es? }
" 	\ \\moretext"

    if a:fd_file == "buffer"
	let l:openbuffer="edit "
    else
	let l:openbuffer="topleft split!"
    endif
    execute l:openbuffer . " +setlocal\\ ft=tex\\ modifiable\\ noro " . l:testfont_file 
    map <buffer> q :bd!<CR>

    call setline(1,'\documentclass{article}')
    call setline(2,'\oddsidemargin=0pt')
    call setline(3,'\textwidth=450pt')
    call setline(4,'\textheight=700pt')
    call setline(5,'\topmargin=-10pt')
    call setline(6,'\headsep=0pt')
    call setline(7,'\begin{document}')

    let l:i=8
    let l:j=1
    let l:len_font_decl=len(l:font_decl)
    let b:match=[]
    for l:font in l:font_decl
	" SHOW THE FONT ENCODING, FAMILY, SERIES and SHAPE
	if matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{\zs[^#}]*\ze}\s*{[^#}]*}') == "b" ||
		    \ matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{\zs[^#}]*\ze}\s*{[^#}]*}') == "bx"
	    let b:show_font='\noindent{\large \textit{Font Encoding}: \textsf{' . 
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{\zs[^#}]*\ze}\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}') . '}' . 
			\ ' \textit{Font Family}: \textsf{' .  
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{[^}#]*}\s*{\zs[^#}]*\ze}\s*{[^#}]*}\s*{[^#}]*}') . '}' . 
			\ ' \textit{Font Series}: \textsf{' .  
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{\zs[^#}]*\ze}\s*{[^#}]*}') . '}' . 
			\ ' \textit{Font Shape}: \textsf{' .  
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}\s*{\zs[^#}]*\ze}') . '}}\\[2pt]'
	else
	    let b:show_font='\noindent{\large \textbf{Font Encoding}: \textsf{' . 
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{\zs[^#}]*\ze}\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}') . '}' . 
			\ ' \textbf{Font Family}: \textsf{' .  
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{[^}#]*}\s*{\zs[^#}]*\ze}\s*{[^#}]*}\s*{[^#}]*}') . '}' . 
			\ ' \textbf{Font Series}: \textsf{' .  
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{\zs[^#}]*\ze}\s*{[^#}]*}') . '}' . 
			\ ' \textbf{Font Shape}: \textsf{' .  
			\ matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}\s*{\zs[^#}]*\ze}') . '}}\\[2pt]'
	endif
	call setline(l:i,b:show_font)
	let l:i+=1
	" CHANGE THE FONT
	call setline(l:i,'{' . substitute(
		    \ matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}'),
		    \ l:declare_command,'usefont','') . 
		    \ '\selectfont')
	" WRITE SAMPLE TEXT
	call add(b:match,matchstr(l:font,'\\'.l:declare_command.'\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}\s*{[^#}]*}'))
	let l:i+=1
	" END
	if l:j<l:len_font_decl
	    call setline(l:i,s:text . '}\\\\')
	else
	    call setline(l:i,s:text . '}')
	endif
	let l:i+=1
	let l:j+=1
    endfor
    call setline(l:i,'\end{document}')
    silent w
    if b:texcompiler =~ '^pdf'	
	let l:ext=".pdf"
    else
	let l:ext=".dvi"
    endif
    call system(b:texcompiler . " " . l:testfont_file . 
	    \ " && " . b:Viewer . " " . fnamemodify(l:testfont_file,":p:r") . l:ext ." &")
    if !a:keep_tex
	silent exe "bd"
    endif
endfunction
" }}}2
"{{{2 FontPreview
" a:fd_file  pattern to find fd file (.fd will be appended if it is not
" present at the end),
" a:1 = encoding
" a:2 = l:keep_tex, i.e. show the tex source.
function! atplib#FontPreview(fd_file,...)
    if a:0 == 0
	let l:keep_tex=0
	let l:enc=""
    elseif a:0 == 1
	let l:enc=a:1
	let l:keep_tex=0
    elseif a:0 ==2
	let l:enc=a:1
	let l:keep_tex=a:2
    endif
    if filereadable(a:fd_file)
	let l:fd_file=a:fd_file
    else
	" Find fd file
	if a:fd_file !~ '.fd\s*$'
	    let l:fd_file=a:fd_file.".*.fd"
	else
	    let l:fd_file=a:fd_file
	endif
	let l:path=substitute(substitute(system("kpsewhich -show-path tex"),'!!','','g'),'\/\/\+','\/','g')
	let l:path=substitute(l:path,':\|\n',',','g')
	let l:fd_all=split(globpath(l:path,"**/*.fd"),'\n') 
	let l:fd=filter(l:fd_all,'v:val =~ l:fd_file && fnamemodify(v:val,":t") =~ "^".l:enc')
	if len(l:fd) == 0
	    echo "FD file not found."
	    return
	elseif len(l:fd) == 1
	    let l:fd_file=l:fd[0]
	else
	    let l:i=1
	    for l:f in l:fd
		echo l:i." ".substitute(f,'^'.fnamemodify(f,":h:h").'/\?','','')
		let l:i+=1
	    endfor
	    let l:choice=input('Which fd file? ')
	    if l:choice == "" 
		return
	    endif
	    let l:fd_file=get(l:fd,l:choice-1,"return")
	    if l:fd_file == "return"
		return
	    endif
	endif
    endif
    call atplib#Preview(l:fd_file,l:keep_tex)
endfunction
"}}}2
" }}}1
" vim:fdm=marker:ff=unix:noet:ts=8:sw=4:fdc=1
